# 🎨 Guía COMPLETA de Integración Frontend - Nectárea API

## 🚀 PASO A PASO DESDE CERO - Para Desarrolladores Frontend

Esta guía asume que **NO sabes nada** sobre el backend de Nectárea. Vamos a explicar TODO desde cero.


---

## ❓ ¿Qué es esta API?

Nectárea es una plataforma de **crowdfunding** (como Kickstarter) donde:

- Los usuarios pueden **invertir** en proyectos
- Los usuarios pueden hacer **pujas** (como subastas)
- Los usuarios pueden **suscribirse** a proyectos mensuales
- Todo se paga con **Mercado Pago**

La API es el backend que maneja toda la lógica y la base de datos.

---

## 📚 Antes de Empezar

### ¿Qué necesitas saber?

- ✅ JavaScript básico
- ✅ Conceptos de HTTP (GET, POST, PUT, DELETE)
- ✅ JSON
- ✅ React/Vue/Angular (cualquier framework frontend)

### ¿Qué NO necesitas saber?

- ❌ Node.js o Express (el backend ya está hecho)
- ❌ PostgreSQL (la base de datos ya está configurada)
- ❌ Cómo funcionan los webhooks internamente

### Herramientas Requeridas

- **Node.js** v18+ (para correr el backend localmente)
- **PostgreSQL** v14+ (base de datos)
- **Git** (para clonar el repositorio)
- **Postman** o **Thunder Client** (para probar la API)

---

## 🔧 PASO 1: Configuración del Backend

### 1.1 Clonar el Repositorio

```bash
# Abre tu terminal y ejecuta:
git clone https://github.com/SebastianASU2005/Nectarea_BD.git
cd Nectarea_BD
```

### 1.2 Instalar Dependencias

```bash
npm install
```

⏳ Esto tomará unos minutos. Está instalando todas las librerías necesarias.

### 1.3 Instalar y Configurar PostgreSQL

#### En Windows:

1. Descarga PostgreSQL: https://www.postgresql.org/download/windows/
2. Instala con los valores por defecto
3. Durante la instalación, anota la contraseña que elijas (la necesitarás)
4. Puerto por defecto: **5432**

#### En Mac:

```bash
brew install postgresql@14
brew services start postgresql@14
```

#### En Linux (Ubuntu/Debian):

```bash
sudo apt update
sudo apt install postgresql postgresql-contrib
sudo systemctl start postgresql
```

### 1.4 Crear la Base de Datos

Abre tu terminal y ejecuta:

```bash
# Conectarse a PostgreSQL
psql -U postgres

# Dentro de psql, ejecuta:
CREATE DATABASE nectarea_dev;
CREATE USER nectarea_user WITH PASSWORD 'dev_password_123';
GRANT ALL PRIVILEGES ON DATABASE nectarea_dev TO nectarea_user;

# Salir de psql
\q
```

✅ **Importante:** Anota estos datos, los necesitarás en el siguiente paso.

### 1.5 Configurar Variables de Entorno

Crea un archivo `.env` en la raíz del proyecto:

```bash
# En la carpeta Nectarea_BD/, crea el archivo .env
touch .env
```

Abre `.env` con tu editor favorito y copia esto:

```env
# === ENTORNO ===
NODE_ENV=development

# === SERVIDOR ===
PORT=3000
HOST_URL=http://localhost:3000
FRONTEND_URL=http://localhost:5173

# === BASE DE DATOS ===
DB_HOST=localhost
DB_PORT=5432
DB_NAME=nectarea_dev
DB_USER=nectarea_user
DB_PASSWORD=dev_password_123
DB_DIALECT=postgres

# === JWT (AUTENTICACIÓN) ===
JWT_SECRET=mi_secreto_super_seguro_de_desarrollo_cambiar_en_produccion
JWT_EXPIRES_IN=7d

# === MERCADO PAGO (MODO PRUEBA) ===
# Deja estos valores vacíos por ahora, los configuraremos después
MP_ACCESS_TOKEN=
MP_WEBHOOK_SECRET=
MP_CURRENCY_ID=ARS

# === EMAIL (OPCIONAL EN DESARROLLO) ===
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_SECURE=false
EMAIL_USER=
EMAIL_PASSWORD=
EMAIL_FROM=noreply@nectarea.com
```

⚠️ **MUY IMPORTANTE:**

- Usa los mismos valores que creaste en el paso 1.4
- Si tu contraseña de PostgreSQL es diferente, cámbiala en `DB_PASSWORD`
- Si usas otro puerto, cámbialo en `DB_PORT`

### 1.6 Inicializar la Base de Datos

```bash
npm run migrate
```

Esto creará todas las tablas automáticamente. Verás mensajes como:

```
Executing (default): CREATE TABLE IF NOT EXISTS "usuarios"...
Executing (default): CREATE TABLE IF NOT EXISTS "proyectos"...
✅ Base de datos sincronizada
```

### 1.7 Iniciar el Backend

```bash
npm run dev
```

Deberías ver:

```
✅ Conectado a la base de datos PostgreSQL
✅ Servidor corriendo en http://localhost:3000
✅ Mercado Pago SDK configurado (o ⚠️ si no configuraste MP aún)
```

### 1.8 Verificar que Funciona

Abre tu navegador y ve a:

```
http://localhost:3000/api/health
```

Deberías ver:

```json
{
  "status": "ok",
  "timestamp": "2025-10-15T10:30:00.000Z"
}
```

✅ **¡Perfecto! El backend está corriendo.**

---

## ⚙️ PASO 2: Configuración del Frontend

### 2.1 Crear Tu Proyecto Frontend

```bash
# Si usas React con Vite:
npm create vite@latest nectarea-frontend -- --template react
cd nectarea-frontend
npm install

# Si usas Vue:
npm create vite@latest nectarea-frontend -- --template vue
cd nectarea-frontend
npm install
```

### 2.2 Instalar Axios (Para Comunicarte con la API)

```bash
npm install axios
```

### 2.3 Crear el Archivo de Configuración de la API

Crea un archivo: `src/services/api.js`

```javascript
// src/services/api.js
import axios from "axios";

// URL del backend (cámbialo según tu entorno)
const API_URL = import.meta.env.VITE_API_URL || "http://localhost:3000/api";

// Crear instancia de axios con configuración base
const apiClient = axios.create({
  baseURL: API_URL,
  timeout: 15000, // 15 segundos
  headers: {
    "Content-Type": "application/json",
  },
});

// ============================================
// INTERCEPTOR DE REQUEST (Agrega el token automáticamente)
// ============================================
apiClient.interceptors.request.use(
  (config) => {
    // Obtener el token del localStorage
    const token = localStorage.getItem("token");

    // Si existe, agregarlo al header
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }

    console.log(`📤 ${config.method.toUpperCase()} ${config.url}`);
    return config;
  },
  (error) => {
    console.error("❌ Error en request:", error);
    return Promise.reject(error);
  }
);

// ============================================
// INTERCEPTOR DE RESPONSE (Maneja errores automáticamente)
// ============================================
apiClient.interceptors.response.use(
  (response) => {
    console.log(`✅ Respuesta recibida de ${response.config.url}`);
    return response;
  },
  (error) => {
    if (error.response) {
      const { status } = error.response;

      // Si el token expiró o es inválido
      if (status === 401) {
        console.error("🚫 Token inválido o expirado");
        localStorage.removeItem("token");
        localStorage.removeItem("user");
        window.location.href = "/login";
      }

      // Si no tiene permisos
      if (status === 403) {
        console.error("🚫 No tienes permisos para esta acción");
      }
    } else if (error.request) {
      console.error("❌ No se pudo conectar con el servidor");
    }

    return Promise.reject(error);
  }
);

export default apiClient;
```

### 2.4 Crear Variables de Entorno del Frontend

Crea un archivo `.env` en la raíz de tu proyecto frontend:

```env
VITE_API_URL=http://localhost:3000/api
```

### 2.5 Probar la Conexión

Crea un archivo: `src/services/authService.js`

```javascript
// src/services/authService.js
import apiClient from "./api";

// Función de prueba
export const testConnection = async () => {
  try {
    const response = await apiClient.get("/health");
    console.log("✅ Conexión exitosa:", response.data);
    return response.data;
  } catch (error) {
    console.error("❌ Error de conexión:", error);
    throw error;
  }
};
```

Ahora, en tu componente principal (App.jsx o similar):

```jsx
import { useEffect } from "react";
import { testConnection } from "./services/authService";

function App() {
  useEffect(() => {
    testConnection();
  }, []);

  return <div>Nectárea Frontend</div>;
}

export default App;
```

Inicia tu frontend:

```bash
npm run dev
```

Abre la consola del navegador (F12) y deberías ver:

```
📤 GET /health
✅ Respuesta recibida de /health
✅ Conexión exitosa: { status: 'ok', timestamp: '...' }
```

✅ **¡Perfecto! Tu frontend se comunica con el backend.**

---

## 🚀 PASO 3: Entendiendo los Modelos de Base de Datos

### ¿Qué es un Modelo?

Un **Modelo** es la representación en código de una **tabla** en la base de datos (DB), utilizando Sequelize. Define las columnas, los tipos de datos y las restricciones.

| Modelo (Sequelize)    | Tabla (DB)             | Propósito Principal                                             |
| :-------------------- | :--------------------- | :-------------------------------------------------------------- |
| `Usuario`             | `usuario`              | Gestión de cuentas de usuario.                                  |
| `Proyecto`            | `proyecto`             | Detalles y estado de los proyectos de inversión.                |
| `Transaccion`         | `transaccion`          | Registro central de flujos de dinero.                           |
| `SuscripcionProyecto` | `suscripcion_proyecto` | Vínculo y estado de la suscripción de un usuario a un proyecto. |
| `Puja`                | `puja`                 | Registro de las ofertas en las subastas de lotes.               |

---

### Modelos Principales del Sistema

#### 1. Usuario (`usuario`)

| Atributo             | Tipo de Dato  | Observaciones Clave                                          |
| :------------------- | :------------ | :----------------------------------------------------------- |
| **`id`**             | `INTEGER`     | Clave primaria.                                              |
| `nombre`, `apellido` | `STRING(100)` |                                                              |
| **`email`**          | `STRING(255)` | Único.                                                       |
| **`dni`**            | `STRING(20)`  | Único.                                                       |
| `nombre_usuario`     | `STRING(50)`  | Único.                                                       |
| `contraseña_hash`    | `STRING(255)` | Clave hasheada.                                              |
| **`rol`**            | `ENUM`        | Opciones: **`"admin"`, `"cliente"`** (Defecto: `"cliente"`). |
| **`activo`**         | `BOOLEAN`     | **Define si la cuenta está activa** (Defecto: `false`).      |
| `confirmado_email`   | `BOOLEAN`     | Indica si el email ha sido verificado.                       |
| `is_2fa_enabled`     | `BOOLEAN`     | Indica si la Autenticación de Dos Factores está activa.      |
| `twofa_secret`       | `STRING(255)` | Clave secreta para TOTP/2FA.                                 |

<br>

#### 2. Proyecto (`proyecto`)

| Atributo                       | Tipo de Dato     | Observaciones Clave                                          |
| :----------------------------- | :--------------- | :----------------------------------------------------------- |
| **`id`**                       | `INTEGER`        | Clave primaria.                                              |
| `nombre_proyecto`              | `STRING(255)`    |                                                              |
| `descripcion`                  | `TEXT`           |                                                              |
| **`tipo_inversion`**           | `ENUM`           | Opciones: **`"directo"`, `"mensual"`**.                      |
| `monto_inversion`              | `DECIMAL(18, 2)` | El monto objetivo de inversión.                              |
| **`estado_proyecto`**          | `ENUM`           | Opciones: **`"En Espera"`, `"En proceso"`, `"Finalizado"`**. |
| `suscripciones_actuales`       | `INTEGER`        | Contador de suscripciones activas.                           |
| `fecha_inicio`, `fecha_cierre` | `DATEONLY`       |                                                              |
| `pack_de_lotes`                | `BOOLEAN`        | Indica si el proyecto gestiona subastas de lotes.            |

<br>

#### 3. Transacción (`transaccion`)

| Atributo                 | Tipo de Dato     | Observaciones Clave                                                    |
| :----------------------- | :--------------- | :--------------------------------------------------------------------- |
| **`id`**                 | `INTEGER`        | Clave primaria.                                                        |
| `id_usuario`             | `INTEGER`        | Usuario que realiza la transacción.                                    |
| `monto`                  | `DECIMAL(15, 2)` | Monto de la transacción.                                               |
| `tipo_transaccion`       | `STRING(50)`     | Tipo de transacción (e.g., "Inversion", "Puja", "PagoMensual").        |
| **`estado_transaccion`** | `ENUM`           | Opciones: **`"pendiente"`, `"pagado"`, `"fallido"`, `"reembolsado"`**. |
| `id_pago_mensual`        | `INTEGER`        | **FK a la tabla `Pago`** (Pago de mensualidad).                        |
| `id_pago_pasarela`       | `INTEGER`        | **FK a la tabla `PagoMercado`** (Pago vía pasarela).                   |
| `id_inversion`           | `INTEGER`        | FK a `Inversion` (si aplica).                                          |
| `id_puja`                | `INTEGER`        | FK a `Puja` (si aplica).                                               |

<br>

#### 4. PagoMercado (`pagos_mercado`)

| Atributo                  | Tipo de Dato     | Observaciones Clave                                                                     |
| :------------------------ | :--------------- | :-------------------------------------------------------------------------------------- |
| **`id`**                  | `INTEGER`        | Clave primaria.                                                                         |
| **`id_transaccion`**      | `INTEGER`        | **FK a la tabla `Transaccion`**.                                                        |
| `id_transaccion_pasarela` | `STRING`         | ID único en la pasarela (e.g., Mercado Pago ID).                                        |
| `monto_pagado`            | `DECIMAL(10, 2)` | Monto real pagado a través de la pasarela.                                              |
| `metodo_pasarela`         | `STRING`         | e.g., `"mercadopago"`, `"stripe"`.                                                      |
| **`estado`**              | `ENUM`           | Opciones: **`"pendiente"`, `"aprobado"`, `"rechazado"`, `"devuelto"`, `"en_proceso"`**. |
| `detalles_raw`            | `JSON`           | Objeto completo del webhook/API.                                                        |

<br>

#### 5. SuscripcionProyecto (`suscripcion_proyecto`)

| Atributo             | Tipo de Dato     | Observaciones Clave                          |
| :------------------- | :--------------- | :------------------------------------------- |
| **`id`**             | `INTEGER`        | Clave primaria.                              |
| `id_usuario`         | `INTEGER`        | Usuario suscrito.                            |
| `id_proyecto`        | `INTEGER`        | Proyecto suscrito.                           |
| **`meses_a_pagar`**  | `INTEGER`        | Cantidad de meses que el usuario debe pagar. |
| `tokens_disponibles` | `INTEGER`        | Tokens acumulados para pujas (Defecto: `1`). |
| `saldo_a_favor`      | `DECIMAL(15, 2)` | Saldo proveniente de pagos excedentes.       |

<br>

#### 6. Pago (de Suscripción) (`pago`)

| Atributo             | Tipo de Dato     | Observaciones Clave                                                                         |
| :------------------- | :--------------- | :------------------------------------------------------------------------------------------ |
| **`id`**             | `INTEGER`        | Clave primaria.                                                                             |
| **`id_suscripcion`** | `INTEGER`        | Suscripción a la que pertenece el pago.                                                     |
| `id_usuario`         | `INTEGER`        | Usuario responsable del pago.                                                               |
| `id_proyecto`        | `INTEGER`        | Proyecto asociado.                                                                          |
| `monto`              | `DECIMAL(15, 2)` | Monto a pagar por la cuota.                                                                 |
| `fecha_vencimiento`  | `DATEONLY`       |                                                                                             |
| **`estado_pago`**    | `ENUM`           | Opciones: **`"pendiente"`, `"pagado"`, `"vencido"`, `"cancelado"`, `"cubierto_por_puja"`**. |
| `mes`                | `INTEGER`        | Mes de la cuota.                                                                            |

---

### Modelos de Subasta

#### 7. Lote (`lote`)

| Atributo                     | Tipo de Dato     | Observaciones Clave                                       |
| :--------------------------- | :--------------- | :-------------------------------------------------------- |
| **`id`**                     | `INTEGER`        | Clave primaria.                                           |
| `id_proyecto`                | `INTEGER`        | Proyecto al que pertenece.                                |
| `nombre_lote`                | `STRING(255)`    | Nombre del lote.                                          |
| `precio_base`                | `DECIMAL(10, 2)` | Precio mínimo para la subasta.                            |
| **`estado_subasta`**         | `ENUM`           | Opciones: **`"pendiente"`, `"activa"`, `"finalizada"`**.  |
| `id_ganador`                 | `INTEGER`        | ID del usuario ganador.                                   |
| **`intentos_fallidos_pago`** | `INTEGER`        | Contador de incumplimientos de pago del ganador (máx. 3). |
| `excedente_visualizacion`    | `DECIMAL(10, 2)` | Excedente de la puja ganadora para frontend.              |

<br>

#### 8. Puja (`puja`)

| Atributo                 | Tipo de Dato     | Observaciones Clave                                                         |
| :----------------------- | :--------------- | :-------------------------------------------------------------------------- |
| **`id`**                 | `INTEGER`        | Clave primaria.                                                             |
| `id_lote`                | `INTEGER`        | Lote subastado.                                                             |
| `id_usuario`             | `INTEGER`        | Usuario que realiza la puja.                                                |
| `monto_puja`             | `DECIMAL(15, 2)` | Monto ofertado.                                                             |
| **`estado_puja`**        | `ENUM`           | Estados detallados: `"activa"`, `"ganadora_pendiente"`, `"perdedora"`, etc. |
| `fecha_vencimiento_pago` | `DATE`           | Fecha límite para que el ganador pague.                                     |
| `id_suscripcion`         | `INTEGER`        | Suscripción asociada a la puja.                                             |

---

### Otros Modelos de Apoyo

#### 9. Inversion (`inversion`)

| Atributo                         | Tipo de Dato     | Observaciones Clave                                                |
| :------------------------------- | :--------------- | :----------------------------------------------------------------- |
| **`id`**                         | `INTEGER`        | Clave primaria.                                                    |
| `monto`                          | `DECIMAL(15, 2)` | Dinero invertido.                                                  |
| `id_usuario` / **`id_inversor`** | `INTEGER`        | Usuario que invierte (Nota: FK en asociaciones es `id_inversor`).  |
| `id_proyecto`                    | `INTEGER`        | Proyecto invertido.                                                |
| **`estado`**                     | `ENUM`           | Opciones: `"pendiente"`, `"pagado"`, `"fallido"`, `"reembolsado"`. |
| `fecha_inversion`                | `DATE`           |                                                                    |

<br>

#### 10. Contrato (`contrato`)

| Atributo                | Tipo de Dato | Observaciones Clave                             |
| :---------------------- | :----------- | :---------------------------------------------- |
| **`id`**                | `INTEGER`    | Clave primaria.                                 |
| `id_proyecto`           | `INTEGER`    | Proyecto al que pertenece.                      |
| `id_usuario_firmante`   | `INTEGER`    | Usuario que ha firmado (puede ser nulo).        |
| `nombre_archivo`        | `STRING`     | Nombre del archivo PDF.                         |
| `hash_archivo_original` | `STRING(64)` | **Hash SHA-256 para integridad** del documento. |

<br>

#### 11. CuotaMensual (`cuota_mensual`)

| Atributo                  | Tipo de Dato     | Observaciones Clave                      |
| :------------------------ | :--------------- | :--------------------------------------- |
| **`id`**                  | `INTEGER`        | Clave primaria.                          |
| `id_proyecto`             | `INTEGER`        | Proyecto de suscripción.                 |
| **`valor_mensual_final`** | `DECIMAL(18, 2)` | Monto final que paga el usuario por mes. |
| `total_cuotas_proyecto`   | `INTEGER`        | Duración total de las cuotas.            |

<br>

#### 12. ResumenCuenta (`resumenes_cuentas`)

| Atributo                            | Tipo de Dato | Observaciones Clave                        |
| :---------------------------------- | :----------- | :----------------------------------------- |
| **`id`**                            | `INTEGER`    | Clave primaria.                            |
| **`id_suscripcion`**                | `INTEGER`    | Suscripción a la que pertenece el resumen. |
| `cuotas_pagadas`, `cuotas_vencidas` | `INTEGER`    | Contadores de cuotas.                      |
| `porcentaje_pagado`                 | `FLOAT`      | Porcentaje de avance de la suscripción.    |
| `detalle_cuota`                     | `JSONB`      | Detalles completos de la cuota mensual.    |

<br>

#### 13. Mensaje (`mensaje`)

| Atributo       | Tipo de Dato | Observaciones Clave                |
| :------------- | :----------- | :--------------------------------- |
| **`id`**       | `INTEGER`    | Clave primaria.                    |
| `id_remitente` | `INTEGER`    | ID del usuario que envía.          |
| `id_receptor`  | `INTEGER`    | ID del usuario que recibe.         |
| `contenido`    | `TEXT`       | Contenido del mensaje.             |
| `leido`        | `BOOLEAN`    | Indica si el receptor lo ha leído. |

<br>

#### 14. Imagen (`imagen`)

| Atributo      | Tipo de Dato  | Observaciones Clave                 |
| :------------ | :------------ | :---------------------------------- |
| **`id`**      | `INTEGER`     | Clave primaria.                     |
| `url`         | `STRING(255)` | URL de la imagen.                   |
| `id_proyecto` | `INTEGER`     | Proyecto asociado (puede ser nulo). |
| `id_lote`     | `INTEGER`     | Lote asociado (puede ser nulo).     |

<br>

#### 15. SuscripcionCancelada (`suscripcion_cancelada`)

| Atributo                      | Tipo de Dato     | Observaciones Clave                      |
| :---------------------------- | :--------------- | :--------------------------------------- |
| **`id`**                      | `INTEGER`        | Clave primaria.                          |
| **`id_suscripcion_original`** | `INTEGER`        | FK de la suscripción que fue cancelada.  |
| `id_usuario`, `id_proyecto`   | `INTEGER`        |                                          |
| `meses_pagados`               | `INTEGER`        | Meses pagados hasta la cancelación.      |
| `monto_pagado_total`          | `DECIMAL(15, 2)` | Monto total pagado hasta la cancelación. |
| `fecha_cancelacion`           | `DATE`           |                                          |

---

# ⚠️ PASO 4: Reglas de Negocio CRÍTICAS

¿Qué son las Reglas de Negocio?
Las reglas de negocio son las restricciones, validaciones y procesos que el backend implementa para mantener la integridad y coherencia de los datos. Si no las respetas en el frontend, tus requests fallarán.
¿Por qué es crítico conocerlas?

✅ Evitarás errores 400, 409 y 500
✅ Entenderás por qué ciertas acciones requieren verificaciones previas
✅ Sabrás qué datos validar antes de enviarlos al backend
✅ Implementarás la UI correctamente

🔐 Servicios de Seguridad (Auth Utilities)
authService.js (Backend)
El servicio de seguridad de autenticación es fundamental para el manejo seguro de contraseñas. Su función principal es gestionar el hashing antes del almacenamiento y la comparación segura durante el inicio de sesión.
Librería: bcryptjs (estándar de la industria)
Regla crítica: 🚫 NUNCA almacenar contraseñas en texto plano

Métodos Principales
MétodoPropósitoRegla de NegociohashPasswordConvierte la contraseña de texto plano en un hash seguroSEGURIDAD: La contraseña almacenada en Usuario.contraseña_hash siempre debe ser el resultado de este procesocomparePasswordComprueba si una contraseña ingresada coincide con el hash almacenadoLOGIN: Utilizado durante el inicio de sesión para verificar credenciales sin desencriptar el hash

Detalles de Implementación
hashPassword(password) - Registro
Este método se invoca durante el registro de un nuevo usuario.
Características:

Hashing: Emplea bcrypt.hash junto con un salt (valor aleatorio)
Seguridad: El factor de salt de 10 es un buen compromiso entre seguridad y rendimiento
Protección: Garantiza que hashes distintos se generen incluso para contraseñas idénticas, previniendo ataques de tablas rainbow

Ejemplo de uso:
javascriptconst nuevoUsuario = {
password: "miPasswordSecreta", // Texto plano
};

// 1. Hashear
const hashedPassword = await authService.hashPassword(nuevoUsuario.password);

// 2. Guardar en la DB
// Usuario.create({ ..., contraseña_hash: hashedPassword });

comparePassword(password, hash) - Login
Este método se invoca durante el inicio de sesión.
Características:

Comparación Segura: bcrypt.compare realiza una comparación criptográfica segura
No reversible: No se puede "desencriptar" el hash para obtener la contraseña original

Ejemplo de uso:
javascriptconst usuarioDB = await Usuario.findOne({ where: { email } });

// Verificar la contraseña
const esValido = await authService.comparePassword(
contraseñaIngresada,
usuarioDB.contraseña_hash
);

if (esValido) {
// ✅ Éxito: Generar Token JWT
} else {
// ❌ Error: Credenciales inválidas
}

🔐 Servicio de Autenticación de Dos Factores (2FA)
auth2faService.js (Backend)
Gestiona la Autenticación de Dos Factores utilizando la librería speakeasy para implementar el estándar TOTP (Time-based One-Time Password).
Relación con el modelo Usuario:

is_2fa_enabled (boolean)
twofa_secret (string encriptado)

Métodos Principales
MétodoPropósitoRegla de Negocio CríticagenerateSecretCrea la clave secreta y la URL de aprovisionamiento (código QR)INTEGRACIÓN: La URL debe incluir el email del usuario para identificación clara en la app 2FAverifyTokenVerifica si el código de 6 dígitos es válidoSEGURIDAD: Usa window: 1 para permitir ±30 segundos de desfaseenable2FAMarca al usuario como is_2fa_enabled: trueVALIDACIÓN: Solo llamar después de validar el token de prueba inicialdisable2FADeshabilita el 2FADOBLE VERIFICACIÓN: Requiere contraseña actual + código TOTP actual

Flujo Crítico: Activación de 2FA
La implementación del 2FA impone reglas estrictas sobre el flujo de seguridad.
Proceso de Activación (2 Pasos)
PasoMétodoAcciónPaso A: GeneracióngenerateSecret(email)El sistema genera el código QR y guarda el secreto temporalmentePaso B: ConfirmaciónverifyToken(secret, token)El usuario ingresa un código de prueba. Si es válido, se llama a enable2FA para hacerlo permanente
⚠️ Importante: El secreto NO debe guardarse en la DB hasta confirmar que el usuario configuró correctamente la app.

Flujo Crítico: Desactivación de 2FA
El método disable2FA combina verificaciones de otros servicios para garantizar máxima seguridad:
javascript/_ Lógica clave en disable2FA _/

// 1. Verificar Contraseña (Usa authService)
const passwordMatch = await authService.comparePassword(
currentPassword,
user.contraseña_hash
);

// 2. Verificar Código TOTP (Usa verifyToken del propio servicio)
const isTotpValid = auth2faService.verifyToken(user.twofa_secret, totpCode);

// 3. Desactivar si ambos son correctos
if (passwordMatch && isTotpValid) {
await user.update({
is_2fa_enabled: false,
twofa_secret: null // Eliminar la clave secreta
});
}
Reglas:

✅ Verificación de contraseña → Confirma identidad del usuario
✅ Verificación de código 2FA → Confirma acceso al dispositivo
✅ Eliminación del secreto → Previene reutilización

📄 Servicio de Gestión e Integridad de Contratos
contratoService.js (Backend)
Administra los registros del modelo Contrato. Su función más crítica es garantizar criptográficamente que los documentos legales no han sido manipulados.
Dependencia: Utiliza generateFileHash para verificar integridad.

Métodos Principales
MétodoPropósitoLógica de Negocio Críticacreate(data)Registra un nuevo contratoRequiere hash_archivo_original en data al momento de la creaciónfindAndVerifyById(id)MÉTODO CENTRAL: Obtiene el contrato y verifica su integridadCompara hash_archivo_original (DB) con hash actual del archivo físicofindById(id)Wrapper de findAndVerifyByIdAsegura que la verificación se ejecute siempre por defectocreateSignedContractRegistra el contrato generado y firmado individualmenteEspera URL, Hash y id_usuario_firmante únicosregisterSignatureActualiza un contrato base con datos de firma electrónicaVincula id_inversion_asociada y hash de firma al contrato basesoftDelete(id)Desactiva un contrato (borrado suave)Usa activo: false para mantener historial legal

Regla Crítica: Integridad Criptográfica (Hash Check)
La lógica más importante reside en findAndVerifyById.
🔑 Concepto de Integridad
El campo Contrato.hash_archivo_original almacena el valor de hash del archivo PDF cuando fue cargado por primera vez.
Si el archivo físico cambia de alguna manera, generateFileHash devolverá un valor diferente.

🚨 Mecanismo de Verificación
javascript// Lógica clave dentro de findAndVerifyById
const hashActual = await generateFileHash(contrato.url_archivo);

if (hashActual !== contrato.hash_archivo_original) {
// ⚠️ ¡El archivo físico no coincide con el registro original!
contrato.dataValues.integrity_compromised = true;
console.warn('🚨 INTEGRIDAD COMPROMETIDA:', contrato.id);
} else {
contrato.dataValues.integrity_compromised = false;
}

return contrato;
Pasos:

Obtener el registro del contrato de la DB (incluye hash_archivo_original)
Calcular hash actual del archivo físico con generateFileHash(url_archivo)
Comparar:

✅ Iguales → integrity_compromised: false
❌ Diferentes → integrity_compromised: true + console.warn de seguridad

Flujo de Firma de Contratos
El método registerSignature es clave para finalizar una inversión:
javascript/_ Ejemplo de Uso de registerSignature _/
const firmaExitosa = {
url_documento_firmado: '...',
hash_documento_firmado: '...',
id_inversion_asociada: 45,
fecha_firma: new Date(),
};

await contratoService.registerSignature(idContratoBase, firmaExitosa);
Proceso:

Usuario realiza una inversión
Se genera un documento PDF único para la inversión
registerSignature vincula este documento firmado y su hash de integridad con el contrato base del proyecto
La inversión queda legalmente respaldada

💰 Servicio de Cálculo de Cuotas Mensuales
cuotaMensualService.js (Backend)
Administra el modelo CuotaMensual. Su propósito principal es calcular el monto exacto que los usuarios deben pagar mensualmente por una suscripción.
Aplica directamente la Regla: Los proyectos de tipo mensual DEBEN tener una configuración de cuota.

Métodos Principales
MétodoPropósitoLógica de Negocio Clave_calculateValuesFUNCIÓN CENTRAL: Realiza todos los cálculos financierosDefine valor_mensual_final sumando plan + administración + IVA. Redondea a 2 decimalescreateAndSetProjectAmountCrea la cuota y la vincula al proyectoTRANSACCIÓN CRÍTICA: Usa transacción de Sequelize para crear Cuota Y actualizar monto_inversion del Proyecto atómicamenteupdateRecalcula y actualiza una cuota existenteMantiene coherencia financiera al recalcular y actualizar montos del ProyectofindByProjectIdObtiene historial de cuotas de un proyectoÚtil para seguimiento administrativo

Lógica de Cálculo Financiero
🧮 Fórmula Completa
javascript// 1. Costo Base (valor_movil)
valor_movil = valor_cemento_unidades × valor_cemento

// 2. Total del Plan
total_del_plan = valor_movil × (porcentaje_plan / 100)

// 3. Valor Mensual (Sin Cargos)
valor_mensual = total_del_plan / total_cuotas_proyecto

// 4. Carga Administrativa
carga_administrativa = valor_movil × (porcentaje_administrativo / 100)

// 5. IVA sobre Administración
iva_carga_administrativa = carga_administrativa × (porcentaje_iva / 100)

// 6. Valor Mensual FINAL
valor_mensual_final = valor_mensual + carga_administrativa + iva_carga_administrativa
⚠️ Nota Crítica: Todos los valores se redondean a 2 decimales (toFixed(2)) para garantizar precisión financiera.

Transacciones Atómicas
ObjetoPropósitoImpacto si FallaCuotaMensualCreación/Actualización del registro de cuotaSi falla, el proyecto nunca se actualizaProyectoActualización de monto_inversion con valor_mensual_finalSi falla, la creación de cuota se revierte (rollback)
El flujo asegura: Ambas operaciones se completan con éxito, o ninguna lo hace.
Esto previene que un proyecto de suscripción tenga una cuota en la DB pero muestre un monto de inversión incorrecto.

📧 Servicio de Correo Electrónico (Notificaciones)
emailService.js (Backend)
Gestiona el envío de correos electrónicos transaccionales utilizando nodemailer.

Configuración Base
ComponenteConfiguraciónConsideraciones de SeguridadTransportadornodemailer.createTransportUtiliza variables de entorno (EMAIL_USER, EMAIL_PASS)Proveedorservice: "gmail"En producción, migrar a SendGrid, Mailgun o AWS SESFunción BasesendEmail(to, subject, text, html)Es la única que interactúa con el transportador

Flujos de Comunicación Críticos

1. Confirmación de Cuenta 🔒
   Método: sendConfirmationEmail
   Propósito: Activar la cuenta del usuario recién registrado, asegurando la validez del correo.
   Regla CRÍTICA: La URL de confirmación en el correo debe apuntar a un endpoint del backend que valide el token y cambie el estado del usuario (is_active: true) antes de redirigirlo al frontend.
   javascript/_ Endpoint de ejemplo _/
   // Después de crear el nuevo usuario:
   const token = generateConfirmationToken(newUser.id);
   await emailService.sendConfirmationEmail(newUser, token);

2. Notificación de Ganador de Lote 🏆
   Método: notificarGanadorPuja
   Propósito: Informar al usuario que ha ganado una puja y establecer fecha límite de pago.
   Flujo:

Se activa por el servicio de pujas/lotes al finalizar una subasta
Se maneja la lógica de Reasignación (esReasignacion)
Se establece el plazo fijo de 90 días para completar el pago

javascriptconst limite = new Date(Date.now() + 90 _ 24 _ 60 _ 60 _ 1000).toLocaleDateString();

await emailService.notificarGanadorPuja(
ganador,
lote.id,
limite,
true // esReasignacion
);

3. Notificación de Impago 🛑
   Método: notificarImpago
   Propósito: Informar al usuario que ha perdido un lote por no cumplir con el plazo de 90 días.
   Regla CRÍTICA: El correo debe confirmar explícitamente que el token de subasta ha sido devuelto a la cuenta del usuario.

🖼️ Servicio de Gestión de Imágenes
imagenService.js (Backend)
Administra el modelo Imagen para controlar el contenido visual asociado a Proyectos y Lotes.
Concepto clave: Borrado suave (soft delete) para mantener historial de activos visuales.

Métodos Principales
MétodoPropósitoLógica de Negocio Clavecreate(data)Registra la URL y metadatos de una nueva imagenAsume que el archivo ya fue subido a S3/GCS/etc.softDelete(id)Borrado Lógico: Desactiva la imagen (activo: false)Previene eliminación física del archivofindByProjectIdActivoObtiene galería visual de un proyectoCRÍTICO: Usa activo: true para mostrar solo imágenes disponiblesfindByLoteIdActivoObtiene imágenes específicas de un loteFiltra por activo: truefindAllActivoConsulta general de imágenes visiblesEstándar de la plataforma para listas públicas

Lógica de Borrado Suave
javascript// Borrado suave
async softDelete(id) {
const imagen = await Imagen.findByPk(id);
if (!imagen) return null;

imagen.activo = false; // Solo cambia el estado
return await imagen.save();
}

// Consulta activa
async findByProjectIdActivo(id_proyecto) {
return await Imagen.findAll({
where: {
id_proyecto: id_proyecto,
activo: true, // FILTRO CRÍTICO DE NEGOCIO
},
});
}
Beneficios:

✅ Seguridad y auditoría
✅ Mantiene historial de URLs de contenido subido
✅ Evita que URLs eliminadas accidentalmente reaparezcan
✅ Administradores pueden ver historial completo

💼 Servicio de Gestión de Inversiones
inversionService.js (Backend)
Maneja la creación y confirmación de inversiones de usuarios en proyectos.
Clave: Transaccionalidad y aplicación de reglas para garantizar que los proyectos no acepten inversiones cuando no deben.

Métodos Principales
MétodoPropósitoLógica de Negocio ClavecrearInversionRegistra la intención de inversiónValidación Previa: Chequea que el proyecto no esté Finalizado/Cancelado, sea tipo directo y tenga monto_inversion definidoconfirmarInversionProcesa el pago exitoso de una inversiónTRANSACCIÓN CRÍTICA: Actualiza estado a pagado, incrementa suscripciones_actuales, finaliza Proyecto si es tipo directofindByUserIdObtiene historial de inversiones de un usuarioEsencial para "Mis Inversiones" en el frontendsoftDeleteDesactiva una inversión (borrado suave)Mantiene historial de transacciones

Flujo de Creación de Inversión
Paso 1: crearInversion (Solo registra intención)
javascriptconst nuevaInversion = await Inversion.create({
monto: proyecto.monto_inversion,
estado: "pendiente", // CRÍTICO: Esperando webhook de pago
// ...
});
Validaciones:

✅ Estado: Impide inversión en proyectos Finalizados o Cancelados
✅ Tipo: Asegura que solo proyectos tipo_inversion: 'directo' usen este endpoint
✅ Transacción: Usa transacción de DB para atomicidad

Flujo de Confirmación de Pago
Paso 2: confirmarInversion (Llamado desde webhook de pagos)
Exige una transacción de Sequelize (t) ya iniciada.
javascript// Bloqueo de registros
const inversion = await Inversion.findByPk(id, {
transaction: t,
lock: t.LOCK.UPDATE
});

// Incremento de fondeo
proyecto.suscripciones_actuales += inversion.monto;

// Actualización de estados
inversion.estado = "pagado";

if (proyecto.tipo_inversion === "directo") {
proyecto.estado_proyecto = "Finalizado";
}
Si alguna operación falla: Rollback automático mantiene coherencia de datos.

🔑 Servicio de JSON Web Token (JWT)
jwtService.js (Backend)
Se encarga de la creación, firma y verificación de JSON Web Tokens para manejar sesiones de usuario y flujos de seguridad críticos (como 2FA).
Librería: jsonwebtoken
Clave secreta: process.env.JWT_SECRET

Métodos Principales
MétodoPropósitoDuración (expiresIn)Lógica de Negocio ClavegenerateTokenCrea el token de sesión principal (en login exitoso)1 horaContiene id, nombre_usuario y rol. Se usa para autorización en cada solicitudverifyTokenVerifica y decodifica el token de sesión-Utilizado por middleware de autenticación para proteger rutasgenerate2FATokenCrea un token temporal para proceso de verificación 2FA5 minutosSolo contiene id. Su corta duración mitiga riesgo de roboverify2FATokenVerifica el token de 2FA-Usado para finalizar login después del código TOTP

Reglas de Seguridad Clave

1. Separación de Propósito y Duración (TTL)
   Tipo de TokenTTLUsoSesión (generateToken)1 horaActividad diaria del usuario (consultar proyectos, inversiones, etc.)Proceso (generate2FAToken)5 minutosValidar pasos sensibles (2FA, recuperación contraseña). No reusable

2. Información del Payload
   Sesión Normal:
   javascriptconst payload = {
   id: 42,
   nombre_usuario: "admin_pablo",
   rol: "administrador",
   iat: 1634283600, // Emitido en...
   exp: 1634287200, // Expira en...
   };
   2FA:
   javascriptconst payload = {
   id: 42, // Solo ID
   };
   ⚠️ Consideración CRÍTICA: La variable JWT_SECRET debe ser larga, compleja y única para producción. Si se compromete, todos los tokens quedan vulnerables.

🏆 Servicio de Lotes y Subastas
loteService.js (Backend)
Administra el modelo Lote, que representa los activos que se subastan. Contiene la lógica de negocio más crítica y compleja de la plataforma.

Métodos Principales
MétodoPropósitoLógica de Negocio ClaveupdateActualiza un loteNotificación: Si estado cambia de inactivo a activa, envía mensajes a todos los usuarios activosendAuctionFinaliza una subasta activaTRANSACCIÓN CRÍTICA: Asigna ganador potencial, marca puja ganadora, establece plazo de 90 días, libera tokensasignarSiguientePujaReasigna el lote al siguiente postor válidoNotificación de Reasignación: Usa emailService con flag esReasignacion: trueprocesarImpagoLoteManeja el vencimiento del plazo de pagoCRON JOB: Marca puja como ganadora_incumplimiento, devuelve token, notifica, inicia reasignaciónprepararLoteParaReingresoLimpia un lote para ser reutilizadoDespués de 3 intentos fallidos. Libera último token, elimina pujas, reinicia estado a pendiente

Flujo de Subasta, Pago y Reasignación

1. Finalización de Subasta (endAuction)
   javascriptconst t = await sequelize.transaction();

try {
// Identificación de ganador
const pujaGanadora = await encontrarPujaMasAlta();

// Actualización de estados
lote.estado_subasta = "finalizada";
lote.id_ganador = pujaGanadora.id_usuario;
lote.intentos_fallidos_pago = 1; // Primer intento

puja.estado_puja = "ganadora_pendiente";
puja.fecha_vencimiento_pago = new Date(Date.now() + 90 _ 24 _ 60 _ 60 _ 1000);

await t.commit();

// Post-Commit: Notificar ganador y liberar tokens de perdedores
} catch (error) {
await t.rollback();
}

2. Gestión de Impago (Cron Job → procesarImpagoLote)
   Esta es la lógica de negocio más delicada.
   javascript// Identificación de incumplidor
   const pujaIncumplidora = await encontrarPujaVencida();

// Acciones sobre incumplidor
puja.estado_puja = "ganadora_incumplimiento";

// CRÍTICO: Devolver token
await PujaService.devolverTokenPorImpago(puja);

// Notificar
await emailService.notificarImpago(usuario);

// Contador de intentos
lote.intentos_fallidos_pago++;

if (lote.intentos_fallidos_pago <= 3) {
// Reasignar al siguiente postor
await asignarSiguientePuja(lote.id);
} else {
// Limpiar lote para próximo ciclo
await prepararLoteParaReingreso(lote.id);
}

13.1 mensajeService.js (Backend)
Método Propósito Principal Lógica de Negocio Clave
enviarMensajeSistema FUNCIÓN CLAVE. Crea un mensaje automático con el remitente fijo SYSTEM_USER_ID (ID 1). NOTIFICACIONES: Usado por otros servicios (como loteService) para enviar avisos críticos (ganadores de pujas, impagos, activaciones, etc.).
obtenerPorUsuario Obtiene la bandeja de entrada y salida completa de un usuario. Utiliza el operador [Op.or] para buscar mensajes donde el usuario sea remitente O receptor, permitiendo la vista unificada del buzón.
obtenerConversacion Filtra mensajes entre dos usuarios específicos. Útil para la funcionalidad de chat o soporte directo entre usuarios.
contarNoLeidos Devuelve el número de mensajes pendientes de lectura. Esencial para la funcionalidad del indicador de notificaciones en la interfaz de usuario.
marcarComoLeido Actualiza el estado del mensaje. SEGURIDAD: Solo permite que el usuario que es el receptor del mensaje cambie su estado a leido: true.

Exportar a Hojas de cálculo
13.2 Regla de Negocio Crítica: Usuario del Sistema
La variable SYSTEM_USER_ID = 1 establece una regla de negocio estricta para la mensajería:

Identidad: El usuario con el ID 1 se reserva exclusivamente para la Administración y Notificaciones Automáticas del Sistema.

Propósito de enviarMensajeSistema: Esta función garantiza que las notificaciones transaccionales o críticas enviadas por la aplicación (como la activación de una subasta o la pérdida de un lote) tengan una fuente clara y consistente.

JavaScript

/_ Uso en otro servicio, por ejemplo, al notificar al ganador de una puja _/
await mensajeService.enviarMensajeSistema(
ganador.id,
"¡Felicidades! Has ganado el Lote #10."
);
// En la DB, el id_remitente será '1' (Sistema).
13.3 Consistencia de la Bandeja de Entrada
El método obtenerPorUsuario es la puerta de entrada a la mensajería, asegurando que el usuario vea todos los mensajes relevantes:

Al usar [Op.or] en la consulta, se combinan todos los mensajes donde:

El id_remitente es el usuario actual (mensajes enviados).

El id_receptor es el usuario actual (mensajes recibidos).

Las cláusulas include: [ {model: Usuario, as: "remitente"}, ... ] son necesarias para mostrar en el frontend el nombre de la persona que envía o recibe el mensaje, en lugar de solo su ID.

Servicio de Gestión de Pagos

El servicio pagoService.js administra el modelo Pago y es el responsable de la lógica de facturación mensual para los proyectos de tipo suscripción. Combina el cobro recurrente con la compleja aplicación de saldos a favor generados en el sistema de Pujas.

14.1 pagoService.js (Backend)
Método Propósito Principal Lógica de Negocio Clave
generarPagoMensualConDescuento Crea la cuota del mes, aplicando saldo a favor del usuario. Transacción para decrementar el saldo a favor en la Suscripcion y crear el Pago. Si el saldo cubre la cuota, el estado_pago se marca como cubierto_por_puja.
markAsPaid Finaliza el proceso de pago exitoso. Transacción para marcar el pago como pagado, establecer fecha_pago y enviar notificaciones (email y mensaje interno).
handlePaymentFailure Maneja una transacción de pago fallida (ej. webhook de pasarela). CRÍTICO: Si es el Pago del Mes 1, lo marca como cancelado para prevenir la generación de cuotas futuras. Si es un mes posterior, mantiene el estado pendiente/vencido.
getValidPaymentDetails Recupera y valida un pago para ser procesado por el controlador de pago. Verifica que el usuario autenticado sea el propietario del pago a través de la Suscripcion asociada y que el estado sea pendiente o vencido.
findPaymentsDueSoon / findOverduePayments Consulta pagos próximos a vencer o vencidos. Destinados a ser utilizados por un Scheduler (Cron Job) para enviar recordatorios y notificaciones de morosidad.

Exportar a Hojas de cálculo
14.2 Flujo de Generación de Pagos y Descuentos (generarPagoMensualConDescuento)
Esta función es clave para la automatización de cobros mensuales y la integración del sistema de recompensas (saldos a favor):

Transacción y Obtención de Datos: Se abre una transacción para buscar la SuscripcionProyecto y el Proyecto asociado.

Determinación del Próximo Mes: Se busca el último pago para determinar el proximoMes (Mes 1, 2, 3, etc.).

Lógica de Descuento (Saldo a Favor):

Se obtiene el saldoAFavor actual de la suscripción.

Si saldoAFavor > 0, se calcula el montoAPagar = Math.max(0, cuotaMensual - saldoAFavor).

Se actualiza el campo suscripcion.saldo_a_favor con el remanente.

Estado del Pago:

Si montoAPagar > 0: estado_pago es "pendiente".

Si montoAPagar === 0: estado_pago es "cubierto_por_puja". Esto cierra el pago inmediatamente sin requerir una transacción de pasarela.

Creación y Decremento: Se crea el nuevo registro de Pago con el monto final y se decrementa suscripcion.meses_a_pagar.

Plazo de Vencimiento Fijo
La fecha de vencimiento (fecha_vencimiento) se establece de forma fija al día 10 del mes en curso, facilitando la gestión de la morosidad.

14.3 Gestión de la Morosidad (Cron Jobs)
Los métodos findPaymentsDueSoon y findOverduePayments son la base para un sistema de recordatorios automatizados:

Método Filtro Lógico Propósito
findPaymentsDueSoon Pagos pendiente con fecha_vencimiento entre Hoy y Hoy + 3 días. Enviar Alertas de recordatorio (ej., "Tu pago vence en 3 días").
findOverduePayments Pagos pendiente con fecha_vencimiento anterior a Hoy ([Op.lt]). Enviar Avisos de morosidad y eventualmente aplicar la lógica de suspensión de la suscripción.

Exportar a Hojas de cálculo
El método updateLastNotificationDate es necesario para evitar enviar múltiples recordatorios en un corto período de tiempo a un mismo usuario para el mismo pago pendiente.

Servicio de Pagos (Mercado Pago Integration)

El servicio paymentService.js es la capa de abstracción entre la lógica de negocio de la plataforma y el SDK de Mercado Pago. Su principal responsabilidad es la gestión transaccional de los pagos, asegurando que el estado de la Transaccion interna y los pagos externos sean consistentes.

15.1 paymentService.js (Backend)
Método Propósito Principal Integración Externa Lógica de Negocio Clave
createPaymentSession Genera la URL de pago de Mercado Pago. Preference Envía la transaccionId local como external_reference y configura la notification_url (webhook) para la comunicación asíncrona.
verifyAndFetchPayment Extrae y verifica los detalles de un pago desde un webhook. Payment Filtra por el topic payment y utiliza el paymentId para consultar los detalles a Mercado Pago.
procesarPagosDeMerchantOrder Maneja los pagos agrupados por una Orden de Comercio (MO). MerchantOrder CRÍTICO/TRANSACCIONAL: Procesa cada pago dentro de la MO. Llama a transaccionService.confirmarTransaccion o procesarFalloTransaccion dentro de una transacción de DB para garantizar la atomicidad.
refreshPaymentStatus Consulta el estado de una transacción de forma síncrona (ej., desde un redirect de usuario). Payment Actualiza la tabla PagoMercado y confirma la Transaccion si el estado es pagado.

Exportar a Hojas de cálculo
15.2 Flujo Crítico: Webhooks y Transacciones
La función más importante es procesarPagosDeMerchantOrder, que maneja el webhook de merchant_order. Esta garantiza que las actualizaciones de estado de pago afecten correctamente a la lógica de negocio local:

1. Transaccionalidad (Atomicidad)
   El método inicia una transacción de base de datos (t = await sequelize.transaction()) antes de cualquier procesamiento. Esto es fundamental porque un solo evento de Mercado Pago puede desencadenar múltiples cambios en la base de datos (actualizar Transaccion, crear PagoMercado, actualizar Inversion, etc.).

JavaScript

const t = await sequelize.transaction({ ... });

try {
// ... Lógica de consulta a MP y procesamiento
await transaccionService.confirmarTransaccion(transaccionId, { transaction: t });
// ...
await t.commit();
} catch (error) {
await t.rollback(); // Si algo falla, se revierte todo
// ...
} 2. Mapeo de Estados
El objeto MP_STATUS_MAP es crucial para traducir los estados de la pasarela de pago (ej., approved, rejected) a estados de la plataforma local (pagado, rechazado), manteniendo una nomenclatura interna consistente.

3. Proceso de Pago
   Estado pagado (Aprobado): Si el estado final es pagado, se llama a transaccionService.confirmarTransaccion(..., { transaction: t }). Este servicio es el responsable de ejecutar la lógica de negocio real (ej., crear la inversión o marcar la suscripción como activa).

Estado rechazado/devuelto: Se llama a transaccionService.procesarFalloTransaccion(..., { transaction: t }) para revertir la transacción interna (si es necesario) y notificar al usuario.

Este diseño separa la responsabilidad: el paymentService maneja la comunicación con Mercado Pago, mientras que el transaccionService maneja las reglas de negocio posteriores a la confirmación/falla del pago.

Servicio de Proyectos

¡Perfecto! El proyectoService es crucial para definir la estructura de la inversión, estableciendo las reglas sobre cómo se creará y fondeará cada oportunidad.

Aquí tienes la documentación en formato Markdown para el servicio proyectoService.js:

🏗️ PASO 16: Servicio de Proyectos
El servicio proyectoService.js gestiona el modelo Proyecto, que es el contenedor principal de una oportunidad de inversión. Su función más importante es la validación de las reglas de negocio al momento de la creación, asegurando la consistencia entre el tipo de inversión y sus parámetros asociados (montos, monedas, y lotes).

16.1 proyectoService.js (Backend)
Método Propósito Principal Lógica de Negocio Clave
crearProyecto Crea un proyecto y valida la unicidad de los lotes. Validación Dual: 1. Reglas estrictas por tipo_inversion (directo vs. mensual). 2. CRÍTICO: Evita que los lotes sean reutilizados, buscando conflictos de idProyecto en la base de datos.
findByUserId Obtiene los proyectos en los que un usuario ha invertido. Relación de Inversión: Utiliza include para filtrar proyectos que tienen al menos una Inversion con el id_usuario y estado: "pagado".
update Actualiza un proyecto existente. Flexibilidad: Permite la actualización dentro de una transacción (transaction), lo cual es esencial si la actualización forma parte de un flujo mayor (ej., un proceso de cambio de estado).
findAllActivo / findByIdActivo Consulta proyectos visibles para el usuario. Filtra por activo: true y siempre incluye los modelos Lote e Imagen para presentar la información completa.

Exportar a Hojas de cálculo
16.2 Reglas de Negocio en la Creación (crearProyecto)
La lógica de creación aplica validaciones estrictas basadas en el campo tipo_inversion, definiendo si el proyecto será una inversión única o un fondo de suscripción mensual:

A. Tipo directo (Inversión Única)
Moneda: Fija a "USD".

Objetivo de Suscripciones: Fijo a 0 (irrelevante para este tipo).

Pack de Lotes: Fijo a true (Entrega anticipada activa).

Requisito: monto_inversion debe ser definido (será el monto que cada inversor debe pagar).

B. Tipo mensual (Suscripción)
Moneda: Fija a "ARS".

Pack de Lotes: Fijo a false (Entrega anticipada inactiva).

Requisito: obj_suscripciones debe ser mayor a cero (define la meta de fondeo).

Requisito: monto_inversion debe ser definido (será la cuota base mensual a pagar).

C. Validación de Unicidad de Lotes
Es una regla de negocio crítica que un lote solo puede estar asociado a UN proyecto a la vez.

El servicio busca lotes que el usuario quiere asignar (lotesIds).

Utiliza Lote.findAll con where: { idProyecto: { [Op.ne]: null } } para encontrar cualquier lote de la lista que ya tenga un idProyecto asignado.

Si se encuentran lotes asignados, se lanza un error que impide la creación del proyecto, protegiendo la integridad de la inversión.

JavaScript

// La validación clave de unicidad de lotes
const lotesAsignados = await Lote.findAll({
where: {
id: lotesIds,
idProyecto: { [require("sequelize").Op.ne]: null },
},
});
16.3 Relación Inversor-Proyecto (findByUserId)
Este método es esencial para la interfaz del usuario ("Mis Proyectos"). En lugar de tener una relación directa, la propiedad se determina a través de la tabla Inversion:

Filtra los Proyectos.

Incluye la tabla Inversion con un filtro anidado (where) que exige que el id_usuario sea el consultado Y que el estado de la inversión sea "pagado" (required: true garantiza que solo se traigan los proyectos con esa inversión confirmada).

Esto asegura que solo se muestren los proyectos en los que el usuario es un inversor activo y con pago completado.

Servicio de Pujas y Subastas
El servicio pujaService.js administra el modelo Puja y el sistema de subastas por lote. Es responsable de las reglas de oferta, la gestión del token de subasta (tokens_disponibles en SuscripcionProyecto) y el crucial proceso de aplicación de excedente (saldo_a_favor).

17.1 pujaService.js (Backend)
Método Propósito Principal Lógica de Negocio Clave
create Crea o actualiza una puja en un lote activo. Token Consumo: Si es la primera puja del usuario en el lote, consume 1 token_disponible de la SuscripcionProyecto. Si es una actualización, no consume más tokens. Validación: Asegura que el monto sea mayor que la puja anterior y mayor que la puja más alta.
procesarPujaGanadora CRÍTICO. Aplica el excedente de la puja ganadora después del pago. Transacción que: 1. Cubre Pagos Pendientes (estado_pago: 'pendiente'). 2. Pre-paga Meses Futuros (decrement 'meses_a_pagar'). 3. Asigna el resto a saldo_a_favor. 4. Libera el token de los perdedores (P3, etc.).
requestCheckoutForPuja Inicia el flujo de pago de la puja ganadora. Llama a getValidPaymentDetails para validar la propiedad y el estado, y luego utiliza el transaccionService para generar el checkout de la pasarela.
getValidPaymentDetails Valida que una puja esté lista para pagarse. Asegura que el estado sea ganadora_pendiente y que el userId autenticado sea el propietario.
gestionarTokensAlFinalizar Prepara el lote para la liquidación. Libera los tokens de todos los participantes EXCEPTO el Top 3 (P1, P2, P3), quienes quedan bloqueados hasta que se defina el ganador.
findExpiredGanadoraPendiente Busca pujas que han incumplido su plazo de pago. Utilizado por un Scheduler (Cron Job) para iniciar el proceso de morosidad/impago y reasignación al siguiente postor.
devolverTokenPorImpago Revierte el bloqueo del token tras un impago (más de 90 días). Seguridad: Incrementa solo si el tokens_disponibles es < 1, asegurando que el usuario no obtenga tokens duplicados.

Exportar a Hojas de cálculo
17.2 La Lógica del Excedente (procesarPujaGanadora)
Cuando un usuario paga exitosamente el monto de su puja ganadora, el excedente (monto_puja - precio_base) se distribuye en una estricta jerarquía de prioridades:

Prioridad 1: Cubrir Pagos Pendientes: El excedente se utiliza para cambiar el estado de cualquier Pago mensual pendiente del usuario en ese proyecto a cubierto_por_puja.

Prioridad 2: Pre-pagar Meses Futuros: Si queda excedente, se utiliza para reducir la cuenta de suscripcion.meses_a_pagar al monto de la cuota mensual (monto_inversion).

Prioridad 3: Saldo a Favor: Cualquier remanente después de cubrir los meses futuros se agrega a suscripcion.saldo_a_favor. Este saldo se aplicará automáticamente a la próxima cuota pendiente (ver pagoService).

Prioridad 4: Excedente de Visualización: Si la suscripción ya está totalmente cubierta (meses_a_pagar <= 0), el resto se almacena en lote.excedente_visualizacion.

17.3 Gestión del Token de Subasta (Tokens)
El servicio impone una regla estricta de "Un Token por Proyecto Activo" para la participación:

Bloqueo al Pujar (create): Al hacer la primera puja en cualquier lote de un proyecto, el tokens_disponibles de la SuscripcionProyecto pasa de 1 a 0. Esto impide que el usuario puje en otros lotes del mismo proyecto.

Liberación de Perdedores Masivos (gestionarTokensAlFinalizar): Al final de la subasta, se devuelven los tokens a todos, excepto al Top 3 de postores.

Liberación Final del Perdedor (procesarPujaGanadora): Cuando el ganador (P1 o P2) paga, se libera inmediatamente el token del postor que queda bloqueado (P2 o P3), dejándolo disponible para otro proyecto.

Liberación por Impago (devolverTokenPorImpago): Si un ganador incumple el pago (ej. 90 días), se le devuelve el token para que pueda participar en el futuro, pero la puja se marca como ganadora_incumplimiento.

Servicio de Resumen de Cuenta
El servicio resumenCuentaService.js gestiona el modelo ResumenCuenta, el cual actúa como un snapshot y un indicador de progreso para las inversiones tipo suscripción mensual. Combina los datos de la SuscripcionProyecto y los Pagos realizados para mostrar al usuario su estatus actual.

18.1 resumen_cuenta.service.js (Backend)
Método Propósito Principal Lógica de Negocio Clave
createAccountSummary Inicializa el resumen al crear una suscripción. Atomicidad: Utiliza options (transacción) para asegurar que el resumen se cree junto con la suscripción. Snapshot: Captura el detalle de la CuotaMensual y el total_cuotas_proyecto en el momento de la suscripción para evitar inconsistencias futuras.
updateAccountSummaryOnPayment CRÍTICO. Actualiza el progreso después de un pago exitoso. Cálculo de Progreso: Cuenta los pagos con estado pagado o cubierto_por_puja. Cálculo de Morosidad: Estima las cuotas_vencidas restando las cuotas_pagadas de los mesesTranscurridos desde la creación de la suscripción (moment().diff(...)).
getAccountSummariesByUserId Obtiene todos los resúmenes del usuario. Consulta las SuscripcionProyecto del usuario y realiza un join con ResumenCuenta y Proyecto para retornar la información clave.
findResumenByIdAndUserId Seguridad para consultas individuales. Usa un where en la inclusión de SuscripcionProyecto (where: { id_usuario: userId }) para prevenir el acceso a resúmenes de otros usuarios.
actualizarSaldoGeneral (Simulación) Placeholder para saldos de inversiones directas/pujas. Función de apoyo que indica dónde se integraría la lógica de saldo general del usuario si la plataforma lo requiriera (ej., para reinversión).

Exportar a Hojas de cálculo
18.2 Lógica de Actualización y Progreso (updateAccountSummaryOnPayment)
Esta función es vital para reflejar el estado financiero del inversor.

1. Conteo de Pagos Pagados
   La métrica de cuotas_pagadas es la suma de todos los registros en la tabla Pago asociados a la suscripción que tienen un estado final y exitoso:

Pagos Completados=Pagos(estado=’pagado’)∪Pagos(estado=’cubierto_por_puja’)
El filtro se realiza directamente al incluir el modelo Pago en la consulta a SuscripcionProyecto.

2. Cálculo de Porcentaje
   El porcentaje_pagado se calcula utilizando la cantidad de pagos completados sobre el total de cuotas del proyecto (meses_proyecto):

Porcentaje Pagado=
Total Cuotas Proyecto
Cuotas Pagadas
​
×100 3. Cálculo de Cuotas Vencidas (Morosidad)
El cálculo de cuotas_vencidas es una estimación basada en el tiempo transcurrido desde que se creó la suscripción (fecha de inicio):

Meses Transcurridos: Se calcula la diferencia en meses entre la fecha actual y la fecha de creación de la suscripción (suscripcion.createdAt) usando moment().

Cuotas Vencidas: La morosidad se define como el número de meses que deberían haber sido pagados menos el número de cuotas que fueron pagadas:

Cuotas Vencidas=max(0,Meses Transcurridos−Cuotas Pagadas)
Este cálculo es crucial para generar reportes y automatizar procesos de cobranza o notificación de mora.

Servicio de Suscripción a Proyectos
El servicio suscripcionProyectoService.js administra el modelo SuscripcionProyecto, la entidad que formaliza la relación entre un Usuario y un Proyecto de inversión de tipo mensual. Su responsabilidad principal es gestionar el estado inicial, la vinculación a proyectos y la activación de la lógica de negocio tras el fondeo del proyecto.

19.1 suscripcionProyectoService.js (Backend)
Método Propósito Principal Lógica de Negocio Clave
\_createSubscriptionRecord Crea el registro de suscripción y actualiza el proyecto. Transaccionalidad: Es llamado por TransaccionService y opera dentro de su transacción (t). Fondeo/Notificación: Incrementa suscripciones_actuales del proyecto. Si se alcanza el obj_suscripciones, notifica a todos los usuarios y cambia el estado_proyecto a "En proceso". Inicialización: Fija meses_a_pagar al plazo_inversion total del proyecto.
findByUserId Consulta todas las suscripciones activas de un usuario. Garantiza que solo se muestren las suscripciones a proyectos que también están activo: true (se asume que existe la corrección del alias proyectoAsociado).
findUsersByProjectId Obtiene la lista de usuarios (inversores) de un proyecto. Utiliza include para obtener las instancias de Usuario asociadas a las suscripciones activas.
findSubscriptionsReadyForPayments (CRON Job / Scheduler) Busca suscripciones para generar pagos. Filtra por pago_generado: false y proyectos con objetivo_cumplido: true, indicando que el proceso de generación de cuotas debe iniciar.

Exportar a Hojas de cálculo
19.2 Flujo Crítico: Creación y Fondeo (\_createSubscriptionRecord)
Esta función se ejecuta después de que el usuario ha completado el pago inicial (la primera cuota o el monto base) a través del TransaccionService.

1. Verificación del Proyecto
   Asegura que el proyecto esté activo y no esté en estado "Finalizado" o "Cancelado".

2. Configuración Inicial del Inversor
   El campo meses_a_pagar de la suscripción se inicializa con el plazo_inversion total definido en el proyecto. Este valor se irá decrementando a medida que se realicen pagos o se aplique excedente de pujas.

3. Proceso de Fondeo (Lógica de "Crowdfunding")
   Incremento: El contador proyecto.suscripciones_actuales se incrementa en 1.

Verificación de Objetivo: Comprueba si suscripciones_actuales ha alcanzado o superado el obj_suscripciones.

Activación del Proyecto:

Si se cumple el objetivo y aún no se ha notificado (objetivo_notificado: false), el proyecto se marca como fondeado.

Se actualiza el estado del proyecto a "En proceso".

Notificación Masiva: Se utiliza el MensajeService para enviar una notificación a todos los usuarios activos de la plataforma, informando que el proyecto ha sido fondeado exitosamente y ha comenzado su fase de ejecución.

Atomicidad: Al ejecutarse dentro de la misma transacción (t) que el pago de la Transaccion, se garantiza que el usuario solo obtiene su suscripción si el proyecto se actualiza correctamente y viceversa.

19.3 Inclusión del resumenCuentaService
Aunque el método \_createSubscriptionRecord no llama directamente a resumenCuentaService.createAccountSummary, la importación (// >>> CAMBIO CLAVE 1 <<<) indica que este es el punto lógico en el flujo completo donde se debe inicializar el ResumenCuenta después de la creación de la suscripción, garantizando que el usuario tenga un dashboard financiero desde el inicio.

Servicio de Bajas (Cancelación de Suscripción)

El servicio suscripcionService.js se centra en la gestión del ciclo de vida de la SuscripcionProyecto, siendo su método principal el softDelete, que implementa la lógica de negocio para la cancelación de una suscripción por parte del usuario.

20.1 suscripcionService.js (Backend)
Método Propósito Principal Lógica de Negocio Clave
softDelete CRÍTICO. Cancela una suscripción y prepara el reembolso. Transacción: Opera atómicamente. 1. Soft Delete: Marca activo: false en SuscripcionProyecto. 2. Contadores: Decrementa el contador suscriptores_actuales del proyecto. 3. Registro de Cancelación: Crea un registro detallado en SuscripcionCancelada para registrar el historial de pagos y el monto total pagado, lo cual se usará posteriormente para el proceso de reembolso.
findById Búsqueda simple por ID. Permite obtener la instancia de la suscripción.
findByUserIdAndProjectId Búsqueda por par de claves (Usuario-Proyecto). Útil para verificar si un usuario tiene una suscripción activa a un proyecto específico.

Exportar a Hojas de cálculo
20.2 Flujo Crítico: Cancelación de Suscripción (softDelete)
El método softDelete no realiza una eliminación física, sino que orquesta un proceso transaccional para registrar la cancelación y sus implicaciones financieras.

Inicio Transacción: Se inicia una transacción de Sequelize (t) para asegurar la atomicidad de las operaciones.

Validación: Verifica que la suscripción exista y que aún esté activa.

Soft Delete: La suscripción se actualiza, estableciendo activo en false.

Actualización del Proyecto: El campo suscriptores_actuales en el modelo Proyecto se decrementa en 1, reflejando la pérdida del inversor.

Registro para Reembolso (Modelo SuscripcionCancelada):

Identificación de Pagos: Se consultan todos los registros en la tabla Pago asociados a la suscripción con el estado 'pagado'.

Cálculo: Se suman los montos de todos los pagos exitosos para obtener el montoTotalPagado.

Creación del Registro: Se crea una nueva entrada en el modelo SuscripcionCancelada, capturando:

id_suscripcion_original

monto_pagado_total

meses_pagados

fecha_cancelacion

Propósito: El registro de SuscripcionCancelada es la única fuente de verdad para que el equipo administrativo o un sistema de terceros pueda procesar el reembolso final al inversor de acuerdo con los términos y condiciones de la plataforma.

Cierre de Transacción: Si todas las operaciones son exitosas, se realiza el commit (await t.commit()). En caso de cualquier error, se realiza el rollback (await t.rollback()), dejando la base de datos en su estado original.

Servicio de Transacciones (Motor de Pagos)

El servicio transaccionService.js es la capa de integración de la pasarela de pagos. Su responsabilidad principal es orquestar la creación de la transacción, la generación del checkout y, lo más importante, la ejecución de la lógica de negocio atómica al recibir una confirmación de pago (Webhook).

21.1 transaccion.service.js (Backend)
Método Propósito Principal Lógica de Negocio Clave
iniciarTransaccionYCheckout Punto de Entrada. Crea o reutiliza una Transaccion pendiente y genera la URL de pago. Reintento/Idempotencia: Busca transacciones pendiente o fallido para el mismo ítem (Inversión/Pago) y regenera el checkout (generarCheckoutParaTransaccionExistente). Puja Excepción: Para las Pujas, anula transacciones antiguas y crea una nueva para asegurar el monto actualizado.
generarCheckoutParaTransaccionExistente Flujo de Bajo Nivel. Genera la preferencia de pago en la pasarela. Garantiza que la Transaccion tenga un registro asociado en PagoMercado (findOrCreate), asegurando que el ID de la pasarela (preferenceId) esté vinculado y que la Transaccion esté marcada como pendiente. Requiere una transacción de BD activa.
confirmarTransaccion CRÍTICO (Webhook/Éxito). Procesa el éxito del pago. Idempotencia: Usa Lock de Actualización (t.LOCK.UPDATE) para prevenir doble procesamiento. Switch de Negocio: Ejecuta el flujo específico (manejarPagoSuscripcionInicial, manejarPagoMensual, inversionService.confirmarInversion, pujaService.procesarPujaGanadora) según el tipo_transaccion. Cierre: Marca la Transaccion como pagado y actualiza el saldo general del usuario (resta el monto).
revertirTransaccion CRÍTICO (Reembolso/Error). Procesa la reversión de un pago exitoso. Idempotencia: Solo revierte si el estado es pagado. Switch Inverso: Ejecuta la lógica de negocio opuesta a la confirmación (ej., pagoService.markAsReverted, inversionService.revertirInversion). Cierre: Marca la Transaccion como revertido y devuelve el monto al saldo general del usuario (suma el monto).
fallarTransaccion Maneja fallos notificados por la pasarela (Webhook). Si es un Pago Mensual o Inicial, invoca pagoService.handlePaymentFailure (lo que puede desencadenar la cancelación de la suscripción si es el Mes 1). Marca la Transaccion como fallido.

Exportar a Hojas de cálculo
21.2 Lógica de Suscripciones (Flujos de Confirmación)
El transaccionService contiene la lógica específica para el manejo de los pagos mensuales, que son los flujos más complejos.

A. Flujo pago_suscripcion_inicial (Pago 1)
Cuando se confirma el pago inicial, ocurre una cascada de operaciones críticas:

Se invoca suscripcionService.\_createSubscriptionRecord: Se crea la entidad SuscripcionProyecto, se incrementa el contador del Proyecto y se notifica el fondeo si aplica.

Se vincula la nueva Suscripcion al Pago y a la Transaccion.

Se realiza un decrement atómico en SuscripcionProyecto.meses_a_pagar (se paga el primer mes).

Se invoca pagoService.markAsPaid en el modelo Pago.

Se invoca resumenCuentaService.createAccountSummary: Se inicializa el dashboard financiero del usuario.

Se invoca resumenCuentaService.updateAccountSummaryOnPayment: Se actualiza el resumen (1 cuota pagada, 0% vencido).

B. Flujo mensual (Pagos 2+)
Cuando se confirma un pago mensual recurrente:

Se invoca pagoService.markAsPaid en el modelo Pago.

Se realiza un decrement atómico en SuscripcionProyecto.meses_a_pagar.

Se invoca resumenCuentaService.updateAccountSummaryOnPayment: Se recalcula el progreso (cuotas pagadas y morosidad).

21.3 Manejo de Saldo General (Billetera)
El servicio actúa como el controlador del saldo general del usuario (simulado por resumenCuentaService.actualizarSaldoGeneral):

Operación Tipo de Transacción Impacto en Saldo General
Confirmación (Éxito de Pago) pago_suscripcion_inicial, mensual, directo, Puja Resta el monto (-montoTransaccion). El dinero se va de la cuenta del usuario.
Reversión (Reembolso) Todas (si estaban pagado) Suma el monto (montoTransaccion). El dinero regresa a la cuenta del usuario.

Exportar a Hojas de cálculo
Esto garantiza la doble entrada: al pagar sale dinero, al reembolsar entra dinero.

Servicio de Usuarios
El servicio usuarioService.js es el punto de control para la administración del modelo Usuario. Maneja las funciones de creación de cuentas, verificación de identidad por email, restablecimiento de contraseñas y tareas de mantenimiento del sistema (limpieza de cuentas no utilizadas).

22.1 usuario.service.js (Backend)
Método Propósito Principal Lógica de Negocio/Seguridad Clave
create Registra un nuevo usuario en el sistema. Verificación: Genera un confirmacion_token único y con fecha de expiracion (24 horas). Marca el usuario como confirmado_email: false. Notificación: Envía el email de confirmación inmediatamente a través de emailService.
confirmEmail Activa la cuenta de un usuario. Validación: Busca el token y verifica que confirmacion_token_expiracion no haya pasado ([Op.gt]: new Date()). Activación: Si es válido, actualiza confirmado_email: true y activo: true (se asume que activo es el estado principal de la cuenta).
resendConfirmationEmail Permite reenviar el correo de activación. Genera un nuevo token de confirmación y expira el anterior, actualizando la fecha de caducidad.
generatePasswordResetToken Inicia el flujo de recuperación de contraseña. Genera un reset_password_token seguro y con una expiración corta (1 hora).
findByResetToken Valida el token de recuperación. Busca el token y verifica que no haya expirado, garantizando que el proceso de cambio de contraseña sea sensible al tiempo.
cleanUnconfirmedAccounts Mantenimiento. Elimina cuentas que nunca se activaron. Realiza un Hard Delete (eliminación física de la BD) de los usuarios que no han confirmado su email (confirmado_email: false) y que fueron creados hace más de X días (por defecto 7 días), liberando espacio y garantizando la higiene de la base de datos.
softDelete Desactiva temporalmente un usuario. Establece activo: false para inhabilitar el acceso sin borrar el registro.
findAllActivos Obtiene solo usuarios con cuentas activas. Útil para tareas masivas como notificaciones (visto en suscripcion_proyecto.service).

Exportar a Hojas de cálculo
22.2 Flujos de Seguridad y Tokens
El servicio utiliza crypto.randomBytes(20).toString("hex") para generar tokens criptográficamente seguros para dos propósitos principales:

Propósito Token Almacenado Vigencia Efecto al Fallar la Validación
Confirmación de Email (create, resendConfirmationEmail) confirmacion_token 24 horas El usuario no puede iniciar sesión. Si el token expira, debe solicitar un reenvío.
Restablecimiento de Contraseña (generatePasswordResetToken) reset_password_token 1 hora El usuario no puede cambiar su contraseña y debe iniciar el proceso de recuperación nuevamente.

Exportar a Hojas de cálculo
Nota de Implementación: El uso de [Op.gt]: new Date() es crucial para asegurar que el token sea verificado como "aún no expirado" directamente en la consulta a la base de datos.

```

```
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Controladores y rutas:

7. Mapeo de Controladores: Flujo de Autenticación (auth.controller.js)
Esta sección detalla la funcionalidad de las funciones dentro del controlador de autenticación, que actúan como la capa de orquestación entre las peticiones HTTP y los servicios de negocio (usuarioService, authService, etc.).

7.1. Detalle del Controlador: controllers/auth.controller.js
El controlador de autenticación maneja el flujo más crítico de la API, incluyendo el manejo de contraseñas, tokens JWT, estados de cuenta (activo, confirmado_email) y la Autenticación de Doble Factor (2FA).

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
register	Registra un nuevo usuario en el sistema.	1. Utiliza authService.hashPassword() para cifrar la clave. 2. Llama a usuarioService.create() que persiste el usuario y genera/envía el token de confirmación por email (emailService).	201 (Created): Éxito. 400 (Bad Request): Fallo de validación o usuario existente.
login	Inicia sesión y decide el flujo de seguridad.	1. Verifica credenciales (authService.comparePassword). 2. Bloquea si la cuenta está inactiva o sin confirmar (código 403). 3. Si 2FA está activo: Emite un twoFaToken temporal (5m) y devuelve 202 para forzar el Paso 2. 4. Si 2FA NO está activo: Emite el JWT de sesión final y devuelve 200.	200 (OK): Sesión completa. 202 (Accepted): 2FA requerido. 401 (Unauthorized): Credenciales incorrectas. 403 (Forbidden): Cuenta inactiva/no confirmada.
verify2FA	Completa el proceso de login tras la verificación 2FA.	1. Valida el twoFaToken temporal. 2. Utiliza auth2faService.verifyToken() para validar el código TOTP de 6 dígitos. 3. Si es correcto, emite el JWT de sesión final.	200 (OK): Sesión final. 401 (Unauthorized): Token o código TOTP inválido.
forgotPassword	Inicia el flujo de recuperación de contraseña.	Llama a usuarioService.generatePasswordResetToken(). Envía un email con el resetLink. CRÍTICO: Devuelve siempre 200 con un mensaje genérico (evita enumeración de emails).	200 (OK): Instrucciones enviadas (genérico).
resetPassword	Aplica la nueva contraseña.	1. Verifica la validez y expiración del :token. 2. Hashea la nueva clave. 3. Actualiza el hash de la contraseña y limpia los campos reset_password_token y reset_password_expires en la DB.	200 (OK): Contraseña actualizada. 400 (Bad Request): Token inválido/expirado.
confirmarEmail	Activa la cuenta mediante el enlace.	Llama a usuarioService.confirmEmail() para cambiar confirmado_email a true.	200 (OK): Activación exitosa. 400 (Bad Request): Token inválido.
logout	Cierra la sesión (lógico).	Confirma al cliente que la sesión ha terminado. CRÍTICO: El frontend es responsable de eliminar el JWT de su almacenamiento.	200 (OK).


7.2. Mapeo de Endpoints: routes/auth.routes.js
Este archivo define la estructura de la API para la autenticación. Las rutas protegidas por authMiddleware.authenticate requieren un JWT válido en el header Authorization: Bearer <token>.

Método HTTP	Endpoint Completo	Middleware Requerido	Controlador Mapeado	Propósito del Endpoint
POST	/api/auth/register	Ninguno	authController.register	Registro de nuevos usuarios.
POST	/api/auth/login	Ninguno	authController.login	Paso 1 del inicio de sesión (credenciales).
POST	/api/auth/2fa/verify	Ninguno	authController.verify2FA	Paso 2 del inicio de sesión (código TOTP).
POST	/api/auth/forgot-password	Ninguno	authController.forgotPassword	Solicitud de email para recuperación de contraseña.
POST	/api/auth/reset-password/:token	Ninguno	authController.resetPassword	Aplicar la nueva contraseña.
POST	/api/auth/reenviar_confirmacion	Ninguno	authController.resendConfirmation	Reenvía el enlace de activación de email.
GET	/api/auth/confirmar_email/:token	Ninguno	authController.confirmarEmail	Enlace para activación final de la cuenta.
POST	/api/auth/logout	authenticate	authController.logout	Cierre de sesión (invalida el token en el cliente).
POST	/api/auth/2fa/generate-secret	authenticate	auth2faController.generate2FASecret	Genera y devuelve el QR para la configuración 2FA.
POST	/api/auth/2fa/enable	authenticate	auth2faController.verifyAndEnable2FA	Activa 2FA permanentemente.
POST	/api/auth/2fa/disable	authenticate	auth2faController.disable2FA	Desactiva 2FA (requiere clave y código TOTP).

Mapeo de Controladores: Configuración de 2FA (auth2fa.controller.js)
Este controlador maneja la lógica para que un usuario pueda activar, desactivar y verificar su Autenticación de Dos Factores (TOTP), un proceso que siempre requiere que el usuario esté autenticado previamente (vía JWT).

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
generate2FASecret	Genera la clave secreta y el QR para el setup inicial.	1. Valida que el usuario no tenga 2FA habilitado ya (is_2fa_enabled). 2. Llama a auth2faService.generateSecret() (usando el email como identificador). 3. CRÍTICO: Almacena el secreto (secret) temporalmente en la BD (campo twofa_secret) para el paso de verificación.	200 (OK): Éxito. Devuelve otpauthUrl (URL para generar el QR) y el secret. 400 (Bad Request): 2FA ya habilitado.
verifyAndEnable2FA	Verifica el código de prueba y activa 2FA permanentemente.	1. Valida el secret guardado previamente. 2. Utiliza auth2faService.verifyToken() para validar que el código (token) de 6 dígitos es correcto. 3. Llama a auth2faService.enable2FA() para setear is_2fa_enabled = true en la base de datos.	200 (OK): 2FA habilitado. 401 (Unauthorized): Código TOTP inválido. 400 (Bad Request): Clave secreta no generada previamente.
disable2FA	Desactiva la protección de Doble Factor.	1. Requiere la contraseña del usuario y el código TOTP actual. 2. La lógica de auth2faService.disable2FA() se encarga de: a) Comparar la contraseña. b) Verificar el código TOTP. c) Si ambos son correctos, setea is_2fa_enabled = false y limpia el twofa_secret.	200 (OK): Deshabilitación exitosa. 400 (Bad Request): Contraseña o código TOTP incorrecto.

Este es un excelente controlador para documentar, ya que combina la gestión de archivos, la lógica de negocio, la autorización estricta y la seguridad de integridad documental (hashing).

A continuación, tienes la documentación profesional de los archivos del Controlador y las Rutas de Contratos, siguiendo la estructura solicitada.

7.4. Mapeo de Controladores: Contratos y Seguridad Documental (contrato.controller.js)
Este controlador centraliza la gestión de archivos de contratos y firmas. Su lógica es crítica, ya que aplica reglas estrictas de autorización (basadas en roles y en relaciones con las inversiones/suscripciones) y garantiza la integridad de los documentos mediante el uso de hashes criptográficos.

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
upload	Sube una plantilla de contrato base a un proyecto.	1. Seguridad de Rol: Requiere rol admin (req.user.role === 'admin'). 2. Hashing: Calcula el hash_archivo_original del archivo subido (req.file.path) mediante generateFileHash(). 3. Transacción Segura: Si el registro en contratoService.create() falla, elimina el archivo físico (fs.unlink).	201 (Created): Éxito. 403 (Forbidden): Rol incorrecto. 400 (Bad Request): Archivo faltante.
sign	Sube el contrato firmado por el usuario y registra la firma.	1. Autorización Reforzada: Verifica que el usuario autenticado (req.user.id) sea el dueño de la id_inversion (estado: 'pagado') o id_suscripcion (estado: 'activa') que intenta firmar. 2. Hashing: Calcula el hash_documento_firmado del archivo firmado para verificación futura. 3. Registro: Llama a contratoService.registerSignature() para actualizar el contrato base. CRÍTICO: Limpia el archivo físico si falla cualquier validación o el registro en DB.	200 (OK): Firma registrada. 403 (Forbidden): No tiene autorización (Inversión/Suscripción no válida). 400 (Bad Request): Datos faltantes. 404 (Not Found): Contrato base no existe.
findMyContracts	Obtiene todos los contratos que el usuario autenticado ha firmado o tiene acceso.	Llama a contratoService.findByUserId(userId) filtrando por relación de usuario.	200 (OK).
findById	Obtiene los detalles de un contrato específico.	1. Integridad: Verifica el estado integrity_compromised (asumido por el servicio). Devuelve 409 si el archivo fue alterado. 2. Autorización: Permite el acceso si: es Admin, es el Firmante, o tiene una Inversión/Suscripción en el proyecto. 3. Sanitización: Elimina datos sensibles (firma_digital, hashes) antes de enviarlos al frontend.	200 (OK). 409 (Conflict): Integridad comprometida. 403 (Forbidden): Acceso denegado. 404 (Not Found).
download	Permite la descarga segura del archivo de contrato.	1. Integridad y Autorización: Aplica las mismas comprobaciones que findById para bloquear descargas no autorizadas o de archivos alterados. 2. Entrega: Utiliza res.download() de Express para transmitir el archivo de forma segura.	200 (OK): Inicia la descarga. 409 (Conflict): Integridad comprometida. 403 (Forbidden): Acceso denegado. 404 (Not Found).
softDelete	Marca un contrato como inactivo.	Llama a contratoService.softDelete(id) (asumido: activo: false).	200 (OK). 404 (Not Found).

7.5. Mapeo de Endpoints: routes/contrato.routes.js
El enrutamiento de contratos requiere el uso del middleware Multer para manejar la subida de archivos, además de middleware de autenticación y autorización por rol.

Método HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Propósito y Notas Clave
POST	/api/contratos/upload	authenticate -> authorizeAdmin -> upload.single('contrato')	contratoController.upload	Subida de plantilla de contrato. Requiere rol Admin.
POST	/api/contratos/firmar	authenticate -> upload.single('contrato_firmado')	contratoController.sign	Subida del contrato firmado por el usuario.
GET	/api/contratos/	authenticate -> authorizeAdmin	contratoController.findAll	Lista todos los contratos (Solo Admin).
GET	/api/contratos/mis_contratos	authenticate	contratoController.findMyContracts	Lista los contratos asociados al usuario autenticado.
GET	/api/contratos/descargar/:id	authenticate	contratoController.download	Descarga segura de un contrato. (Ubicación de la ruta CRÍTICA).
GET	/api/contratos/:id	authenticate	contratoController.findById	Obtiene detalles de un contrato específico. (Ubicación de la ruta CRÍTICA).
DELETE	/api/contratos/:id	authenticate -> authorizeAdmin	contratoController.softDelete	Eliminación lógica del contrato.

Mapeo de Controladores: Gestión de Cuotas Mensuales (cuota_mensual.controller.js)
Este controlador se enfoca en la creación y consulta de las cuotas asociadas a los proyectos, siendo crucial para el seguimiento del flujo de inversión. La creación y modificación están estrictamente restringidas a los administradores.

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
create	Registra una nueva cuota mensual en la base de datos.	1. Validación: Verifica la existencia de id_proyecto. 2. Integración: Llama a proyectoService.findById() para obtener datos del proyecto (nombre_proyecto, plazo_inversion). 3. Transacción Clave: Llama a cuotaMensualService.createAndSetProjectAmount() que crea la cuota y ajusta el monto total del proyecto.	201 (Created): Éxito. 400 (Bad Request): id_proyecto faltante. 404 (Not Found): Proyecto inexistente.
findByProjectId	Obtiene todas las cuotas de un proyecto específico.	Llama a cuotaMensualService.findByProjectId(id_proyecto). No requiere validación de rol, solo autenticación.	200 (OK): Lista de cuotas. 500 (Internal Error).
findLastByProjectId	Obtiene la cuota más reciente de un proyecto.	Llama a cuotaMensualService.findLastByProjectId(id_proyecto). Útil para mostrar el estado actual o la siguiente cuota.	200 (OK): Última cuota. 404 (Not Found): Cuotas no encontradas.
update	Modifica los campos de una cuota existente.	Llama a cuotaMensualService.update(id, data).	200 (OK): Actualización exitosa. 404 (Not Found): Cuota inexistente.
softDelete	Elimina lógicamente una cuota (cambio de estado).	Llama a cuotaMensualService.softDelete(id).	200 (OK). 404 (Not Found).


7.7. Mapeo de Endpoints: routes/cuota_mensual.routes.js
Las rutas de Cuotas Mensuales se centran en la seguridad, restringiendo las operaciones de escritura (creación, actualización, eliminación) solo a administradores. Las operaciones de lectura son accesibles para cualquier usuario autenticado.

Método HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Propósito y Requisitos de Seguridad
POST	/api/cuotas/	authenticate -> authorizeAdmin	cuotaMensualController.create	Creación de cuota. Requiere rol Admin.
GET	/api/cuotas/:id_proyecto	authenticate	cuotaMensualController.findByProjectId	Obtiene el historial de cuotas de un proyecto. Solo requiere autenticación de usuario.
GET	/api/cuotas/:id_proyecto/last	authenticate	cuotaMensualController.findLastByProjectId	Obtiene el último registro de cuota. Solo requiere autenticación de usuario.
PUT	/api/cuotas/:id	authenticate -> authorizeAdmin	cuotaMensualController.update	Actualización de cuota por ID. Requiere rol Admin.
DELETE	/api/cuotas/:id	authenticate -> authorizeAdmin	cuotaMensualController.softDelete	Eliminación lógica de cuota por ID. Requiere rol Admin.

Mapeo de Controladores: Gestión de Archivos (Imágenes) (imagen.controller.js)
Este controlador administra la subida, consulta y eliminación lógica de las imágenes asociadas a Proyectos y Lotes. Es notable por su dependencia del middleware de subida de archivos (imageUpload.middleware) y por el uso diferenciado de rutas para administradores y usuarios generales.

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
create	Sube un archivo de imagen y crea el registro en la BD.	1. Manejo de Archivos: Verifica que req.file exista (Multer lo adjuntó). 2. Validación: La imagen debe estar asociada a id_proyecto o id_lote. 3. Registro: Utiliza req.file.path (ruta física) como la URL para imagenService.create().	201 (Created): Éxito. 400 (Bad Request): Archivo faltante o sin asociación.
getImagesByProjectId	Obtiene todas las imágenes activas de un proyecto.	Llama a imagenService.findByProjectIdActivo(id_proyecto).	200 (OK). 400 (Bad Request): ID faltante.
getImagesByLoteId	Obtiene todas las imágenes activas de un lote.	Llama a imagenService.findByLoteIdActivo(id_lote).	200 (OK). 400 (Bad Request): ID faltante.
findByIdActivo	Obtiene una imagen activa por su ID.	Llama a imagenService.findByIdActivo(id). Ruta utilizada por usuarios.	200 (OK). 404 (Not Found).
findById	Obtiene una imagen por ID (incluye inactivas).	Llama a imagenService.findById(id). Ruta utilizada exclusivamente por Administradores.	200 (OK). 404 (Not Found).
findAllActivo	Obtiene una lista de todas las imágenes activas en el sistema.	Llama a imagenService.findAllActivo().	200 (OK).
findAll	Obtiene una lista de todas las imágenes (incluye inactivas).	Llama a imagenService.findAll(). Solo para Administradores.	200 (OK).
update	Actualiza los metadatos de una imagen.	Llama a imagenService.update(id, data). No maneja la subida de un nuevo archivo de imagen.	200 (OK). 404 (Not Found).
softDelete	Marca una imagen como eliminada lógicamente.	Llama a imagenService.softDelete(id) (asumido: activo: false).	200 (OK). 404 (Not Found).


7.9. Mapeo de Endpoints: routes/imagen.routes.js
El enrutamiento de imágenes utiliza un orden específico para manejar las rutas con prefijo (/proyecto/, /lote/, /admin/) antes que la ruta genérica dinámica (/:id). Las operaciones de escritura y consulta de datos sensibles están restringidas al rol Admin.

Método HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Propósito y Requisitos de Seguridad
POST	/api/imagenes/	authenticate -> authorizeAdmin -> imageUpload.single('image')	imagenController.create	Subida de imagen. Requiere Admin y el archivo en form-data con clave image.
GET	/api/imagenes/proyecto/:idProyecto	authenticate	imagenController.getImagesByProjectId	Imágenes activas asociadas a un proyecto.
GET	/api/imagenes/lote/:idLote	authenticate	imagenController.getImagesByLoteId	Imágenes activas asociadas a un lote.
GET	/api/imagenes/activas	authenticate	imagenController.findAllActivo	Lista todas las imágenes activas (para catálogos).
GET	/api/imagenes/	authenticate -> authorizeAdmin	imagenController.findAll	Lista todas las imágenes (incl. inactivas). Requiere Admin.
GET	/api/imagenes/admin/:id	authenticate -> authorizeAdmin	imagenController.findById	Obtiene imagen (activa/inactiva) por ID. Requiere Admin.
GET	/api/imagenes/:id	authenticate	imagenController.findByIdActivo	Obtiene imagen activa por ID. Ruta genérica para usuarios.
PUT	/api/imagenes/:id	authenticate -> authorizeAdmin	imagenController.update	Actualización de metadatos. Requiere Admin.
DELETE	/api/imagenes/:id	authenticate -> authorizeAdmin	imagenController.softDelete	Eliminación lógica. Requiere Admin.

Mapeo de Controladores: Inversiones y Checkout Seguro (inversion.controller.js)
Este controlador maneja el ciclo de vida de una inversión, desde su creación inicial (pendiente) hasta la solicitud de pago, implementando un punto de control de seguridad 2FA antes de la redirección a la pasarela de pago.

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
create	Registra una nueva inversión en estado pendiente de pago.	Llama a inversionService.crearInversion(data). Solo registra la intención y devuelve una URL sugerida para el pago.	201 (Created): Éxito. Devuelve el inversionId. 400 (Bad Request).
requestCheckoutInversion	Inicia el proceso de pago, actuando como control de seguridad 2FA.	1. Validación: Verifica que la inversión exista, pertenezca al usuario y esté pendiente. 2. Control 2FA: Si user.is_2fa_enabled es true, devuelve 202 (Accepted) e informa que se requiere la verificación 2FA. El frontend debe detenerse y solicitar el código. 3. Flujo Normal (Sin 2FA): Si 2FA está desactivado, llama a TransaccionService.iniciarTransaccionYCheckout() y devuelve la redirectUrl a la pasarela.	200 (OK): Redirección directa a la pasarela. 202 (Accepted): 2FA requerido. 403 (Forbidden): Inversión no válida o no pertenece al usuario.
confirmarInversionCon2FA	Ejecuta la transacción solo después de verificar el código 2FA.	1. Verificación: Llama a auth2faService.verifyToken() usando el codigo_2fa proporcionado y el twofa_secret del usuario. 2. Ejecución: Si la verificación 2FA es exitosa (código 200), procede a llamar a TransaccionService.iniciarTransaccionYCheckout() para generar la transacción y la redirectUrl.	200 (OK): Verificación exitosa. Devuelve redirectUrl. 401 (Unauthorized): Código 2FA incorrecto. 403 (Forbidden): Inversión o estado no válidos.
findMyInversions	Obtiene todas las inversiones del usuario autenticado.	Llama a inversionService.findByUserId(userId).	200 (OK).
findMyInversionById	Obtiene una inversión específica verificando que pertenezca al usuario.	Llama a inversionService.findByIdAndUserId(id, userId).	200 (OK). 404 (Not Found).
findAll	Obtiene todas las inversiones (incluye inactivas).	Llama a inversionService.findAll(). Solo para Administradores.	200 (OK).
softDeleteMyInversion	Elimina lógicamente una inversión (si aún está en estado pendiente).	Llama a inversionService.softDeleteByIdAndUserId(id, userId). Solo puede eliminar sus propias inversiones.	204 (No Content): Eliminación exitosa. 404 (Not Found).
softDelete	Elimina lógicamente una inversión (función de Admin).	Llama a inversionService.softDelete(id). Solo para Administradores.	204 (No Content): Eliminación exitosa. 404 (Not Found).


7.11. Mapeo de Endpoints: routes/inversion.routes.js
El enrutamiento de Inversiones es crítico debido a la secuencia de pasos de pago y la seguridad del 2FA. La mayoría de las rutas están protegidas por authMiddleware.authenticate.

Método HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Propósito y Requisitos de Seguridad
POST	/api/inversion/	authenticate	inversionController.create	Registro inicial de la inversión (estado pendiente).
POST	/api/inversion/iniciar-pago/:idInversion	authenticate	inversionController.requestCheckoutInversion	Paso 1 del checkout. Decide si se requiere 2FA o redirige.
POST	/api/inversion/confirmar-2fa	authenticate	inversionController.confirmarInversionCon2FA	Paso 2 del checkout. Verifica el código 2FA y ejecuta la redirección.
GET	/api/inversion/mis_inversiones	authenticate	inversionController.findMyInversions	Lista todas las inversiones del usuario logueado.
GET	/api/inversion/	authenticate -> authorizeAdmin	inversionController.findAll	Lista todas las inversiones (incl. inactivas). Requiere Admin.
GET	/api/inversion/activas	authenticate -> authorizeAdmin	inversionController.findAllActivo	Lista solo inversiones activas. Requiere Admin.
GET	/api/inversion/:id	authenticate	inversionController.findById	Obtiene inversión por ID (Admin) o verifica posesión.
PUT	/api/inversion/:id	authenticate -> authorizeAdmin	inversionController.update	Actualización de inversión. Requiere Admin.
DELETE	/api/inversion/:id	authenticate -> authorizeAdmin	inversionController.softDelete	Eliminación lógica de inversión. Requiere Admin.

Mapeo de Controladores: Gestión de Lotes y Subastas (lote.controller.js)
Este controlador maneja la creación y el mantenimiento de los lotes de inversión y contiene la lógica compleja para iniciar y finalizar el proceso de subasta asociado a cada lote.

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
create	Crea un nuevo lote de inversión.	Llama a loteService.create(data).	201 (Created). 400 (Bad Request).
findAllActivo	Obtiene todos los lotes disponibles para inversión (activos).	Llama a loteService.findAllActivo().	200 (OK).
findByIdActivo	Obtiene un lote específico, solo si está activo.	Llama a loteService.findByIdActivo(id).	200 (OK). 404 (Not Found).
findAll	Obtiene todos los lotes (incluyendo inactivos).	Llama a loteService.findAll(). Solo para Administradores.	200 (OK).
findById	Obtiene un lote por ID (incluye inactivos).	Llama a loteService.findById(id). Solo para Administradores.	200 (OK). 404 (Not Found).
update	Actualiza los datos de un lote.	Llama a loteService.update(id, data).	200 (OK). 404 (Not Found).
softDelete	Elimina lógicamente un lote.	Llama a loteService.softDelete(id).	200 (OK). 404 (Not Found).
startAuction	Inicia el proceso de subasta para un lote.	1. Actualiza estado_subasta a 'activa' y fecha_inicio. 2. CRÍTICO: Utiliza SuscripcionProyectoService para obtener usuarios suscritos al proyecto. 3. Envía un mensaje de notificación a todos los suscriptores a través de mensajeService.crear().	200 (OK). 404 (Not Found): Lote o Proyecto.
endAuction	Finaliza la subasta, determina el ganador y genera la transacción.	1. Llama a la lógica compleja de loteService.endAuction(id). 2. Si hay un ganador (hubo pujas), devuelve la transaccion creada para que el ganador proceda al pago.	200 (OK): Finalización exitosa (con o sin ganador). 400 (Bad Request): Error en la lógica de finalización.


7.13. Mapeo de Endpoints: routes/lote.routes.js
Las rutas de lotes balancean el acceso público a la información de inversión activa y la restricción a las operaciones de control de subasta y mantenimiento, que son exclusivas de los administradores.

Método HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Propósito y Requisitos de Seguridad
POST	/api/lotes/	authenticate -> authorizeAdmin	loteController.create	Creación de lotes. Requiere Admin.
GET	/api/lotes/activos	authenticate	loteController.findAllActivo	Lista todos los lotes activos (para la sección de inversión pública).
GET	/api/lotes/	authenticate -> authorizeAdmin	loteController.findAll	Lista todos los lotes (incl. inactivos). Requiere Admin.
POST	/api/lotes/:id/start_auction	authenticate -> authorizeAdmin	loteController.startAuction	Inicia la subasta de un lote. Requiere Admin.
PUT	/api/lotes/:id/end	authenticate -> authorizeAdmin	loteController.endAuction	Finaliza la subasta de un lote. Requiere Admin.
GET	/api/lotes/:id/activo	authenticate	loteController.findByIdActivo	Obtiene un lote específico solo si está activo.
GET	/api/lotes/:id	authenticate -> authorizeAdmin	loteController.findById	Obtiene un lote por ID (activos/inactivos). Requiere Admin.
PUT	/api/lotes/:id	authenticate -> authorizeAdmin	loteController.update	Actualización de lote. Requiere Admin.
DELETE	/api/lotes/:id	authenticate -> authorizeAdmin	loteController.softDelete	Eliminación lógica de lote. Requiere Admin.

Mapeo de Controladores: Mensajería Interna (mensaje.controller.js)
Este controlador administra la funcionalidad de mensajería privada, permitiendo a los usuarios enviar, recibir, contar y marcar mensajes como leídos. Todas las operaciones requieren autenticación.

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
obtenerMisMensajes	Obtiene la lista completa de mensajes recibidos y enviados por el usuario autenticado.	Llama a mensajeService.obtenerPorUsuario(userId).	200 (OK).
enviarMensaje	Permite al usuario autenticado enviar un mensaje a otro usuario.	Obtiene el id_remitente de req.user.id. Llama a mensajeService.crear().	201 (Created): Éxito. 400 (Bad Request).
obtenerConteoNoLeidos	Proporciona el número de mensajes no leídos para el usuario autenticado.	Llama a mensajeService.contarNoLeidos(userId).	200 (OK). Devuelve un objeto { conteo: N }.
obtenerConversacion	Recupera el historial de mensajes entre el usuario autenticado y un receptor específico.	Llama a mensajeService.obtenerConversacion(userId, id_receptor).	200 (OK).
marcarComoLeido	Marca un mensaje específico como leído por el usuario.	Llama a mensajeService.marcarComoLeido(id, userId). CRÍTICO: Valida que el mensaje sea recibido por el usuario que intenta marcarlo.	200 (OK). 404 (Not Found): Mensaje no existe o no es del usuario.


7.15. Mapeo de Endpoints: routes/mensaje.routes.js
Todas las rutas del sistema de mensajería están protegidas por el middleware de autenticación (authMiddleware.authenticate) para asegurar la privacidad de la comunicación. Es crucial el orden de las rutas estáticas antes que las dinámicas.

Método HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Propósito y Requisitos de Seguridad
GET	/api/mensajes/	authenticate	mensajeController.obtenerMisMensajes	Lista todos los mensajes del usuario (Bandeja de entrada/salida).
POST	/api/mensajes/	authenticate	mensajeController.enviarMensaje	Envío de un nuevo mensaje.
GET	/api/mensajes/no_leidos	authenticate	mensajeController.obtenerConteoNoLeidos	Obtiene el número de mensajes no leídos.
PUT	/api/mensajes/leido/:id	authenticate	mensajeController.marcarComoLeido	Marca un mensaje por ID como leído.
GET	/api/mensajes/:id_receptor	authenticate	mensajeController.obtenerConversacion	Obtiene la conversación con el usuario especificado.

Mapeo de Controladores: Gestión de Pagos y Checkout con 2FA (pago.controller.js)
Este controlador maneja la funcionalidad de pagos, desde la consulta personal y administrativa hasta el proceso crítico de checkout, que utiliza un flujo de bifurcación de seguridad para los usuarios con 2FA activo.

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
requestCheckout	Inicia el proceso de pago para un registro existente.	1. Validación: Llama a pagoService.getValidPaymentDetails(pagoId, userId) para verificar la propiedad y estado. 2. Control 2FA: Si user.is_2fa_enabled es true, devuelve 202 (Accepted) indicando que se requiere el código 2FA. 3. Flujo Normal: Si no hay 2FA, llama a transaccionService.iniciarTransaccionYCheckout() y devuelve la redirectUrl.	200 (Redirección). 202 (2FA Requerido). 403 (No autorizado). 409 (Conflicto/Pago ya procesado).
confirmarPagoYContinuar	Continúa el checkout después de la verificación exitosa del 2FA.	1. Verificación: Llama a auth2faService.verifyToken() con el código proporcionado. 2. Ejecución: Si es correcto, llama a transaccionService.iniciarTransaccionYCheckout() para generar la transacción y la redirectUrl.	200 (Redirección). 401 (Código 2FA incorrecto). 403 (2FA no activo).
findMyPayments	Obtiene la lista de todos los pagos realizados por el usuario autenticado.	Llama a pagoService.findByUserId(userId).	200 (OK).
triggerManualPayment	Genera manualmente un pago a partir de una suscripción.	Llama a pagoService.generarPagoMensualConDescuento(id_suscripcion). Función administrativa para generar pagos a demanda.	201 (Created). 400 (Falta ID).
findAll	Obtiene la lista de todos los pagos en el sistema.	Llama a pagoService.findAll(). Solo para Administradores.	200 (OK).
findById	Obtiene un pago específico por ID.	Llama a pagoService.findById(id). Solo para Administradores.	200 (OK). 404 (Not Found).
update	Actualiza los datos de un pago.	Llama a pagoService.update(id, data). Solo para Administradores.	200 (OK). 404 (Not Found).
softDelete	Elimina lógicamente un pago.	Llama a pagoService.softDelete(id). Solo para Administradores.	200 (OK). 404 (Not Found).


7.17. Mapeo de Endpoints: routes/pago.routes.js
El enrutamiento de Pagos prioriza la seguridad y el flujo del checkout. Es fundamental que las rutas estáticas de usuario (/mis_pagos) y de control de flujo (/confirmar-pago-2fa) se definan antes que las rutas dinámicas genéricas.

Método HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Propósito y Requisitos de Seguridad
GET	/api/pagos/mis_pagos	authenticate	pagoController.findMyPayments	Consulta los pagos del usuario logueado.
POST	/api/pagos/pagar-mes/:id	authenticate	pagoController.requestCheckout	Paso 1 del checkout. Inicia el proceso de pago y verifica si se necesita 2FA.
POST	/api/pagos/confirmar-pago-2fa	authenticate	pagoController.confirmarPagoYContinuar	Paso 2 del checkout. Verifica el código 2FA y redirige a la pasarela.
GET	/api/pagos/	authenticate -> authorizeAdmin	pagoController.findAll	Lista todos los pagos. Requiere Admin.
POST	/api/pagos/trigger-manual-payment	authenticate -> authorizeAdmin	pagoController.triggerManualPayment	Generación manual/simulada de un pago. Requiere Admin.
GET	/api/pagos/:id	authenticate -> authorizeAdmin	pagoController.findById	Obtiene un pago específico por ID. Requiere Admin.
PUT	/api/pagos/:id	authenticate -> authorizeAdmin	pagoController.update	Actualización de pago. Requiere Admin.
DELETE	/api/pagos/:id	authenticate -> authorizeAdmin	pagoController.softDelete	Eliminación lógica de pago. Requiere Admin.

¡Excelente elección! El controlador de Pagos (Mercado Pago) es el más crítico a nivel de infraestructura, ya que gestiona la comunicación segura y asíncrona con la pasarela de pago, implementando validaciones criptográficas.

Aquí tienes la documentación detallada.

7.18. Mapeo de Controladores: Pagos y Pasarela (Mercado Pago) (pagoMercado.controller.js)
Este controlador centraliza toda la lógica relacionada con la creación de checkouts, la gestión de webhooks (notificaciones asíncronas) y la consulta de estados, asegurando la integridad de las transacciones mediante un control estricto de seguridad.

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
verifySignature	CRÍTICA DE SEGURIDAD: Verifica la autenticidad de las notificaciones entrantes de Mercado Pago (Webhooks) utilizando el algoritmo HMAC-SHA256 y la clave secreta configurada.	Interna. Rechaza cualquier solicitud de webhook que no tenga una firma criptográfica válida, protegiendo contra la suplantación de identidad.	N/A (Interna).
iniciarPagoPorModelo	Ruta Estándar: Inicia el proceso de checkout para cualquier modelo pendiente de pago (Inversión, Puja, etc.) de forma genérica.	Llama a transaccionService.iniciarTransaccionYCheckout(modelo, modeloId, userId).	200 (OK): Devuelve redirectUrl. 400 (IDs inválidos).
createCheckoutGenerico	Ruta Avanzada: Crea una nueva Transacción y su checkout MP, o regenera un checkout para una Transacción existente.	Utiliza una Transacción de BD para asegurar atomicidad. Llama a transaccionService.crearTransaccionConCheckout.	200 (OK): Devuelve redirectUrl. 500 (Error de servidor/BD).
handleWebhook	Procesamiento de Webhooks: Maneja las notificaciones de estado enviadas por Mercado Pago.	1. Llama a verifySignature (si falla, devuelve 401). 2. Procesa merchant_order (para actualizar múltiples pagos) o payment. 3. Si es un pago aprobado, llama a transaccionService.confirmarTransaccion dentro de una Transacción de BD con bloqueo (LOCK.UPDATE) para evitar duplicados.	200 (OK): Siempre responde 200 a MP (incluso si hay un error de procesamiento interno) para evitar reintentos. 401 (Unauthorized): Firma Inválida.
handleCheckoutRedirect	Maneja la redirección del usuario (GET) después de interactuar con la pasarela de pago (Mercado Pago).	Revisa el estado de la URL (collection_status). Si el usuario rechaza/cancela el pago, llama a transaccionService.cancelarTransaccionPorUsuario y redirige al frontend a la página de fallo.	302 (Redirect): A la URL del frontend (/pago-estado o /pago-fallido).
getPaymentStatus	Permite al usuario autenticado consultar el estado final de una transacción.	Verifica que la Transacción pertenezca al usuario. Si se solicita refresh=true y la transacción está en proceso, llama a pagoMercadoService.refreshPaymentStatus para obtener el estado más reciente de la pasarela.	200 (OK): Devuelve el estado y los detalles de pago. 404 (No encontrado/No pertenece).
createCheckout	Flujo de compatibilidad con inversiones (envoltorio de createCheckoutGenerico).	Busca la inversión, valida su estado pendiente, y delega en createCheckoutGenerico.	200 (OK). 404 (Inversión no encontrada).


7.19. Mapeo de Endpoints: routes/pagoMercado.routes.js
Estas rutas requieren autenticación, salvo las dos rutas públicas (/webhook y /redirect) que deben ser accesibles para la pasarela de pago.

Método HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Propósito y Requisitos de Seguridad
POST	/api/payment/checkout/:modelo/:modeloId	authenticate	paymentController.iniciarPagoPorModelo	Flujo Estándar: Inicia el pago para un registro (ej. /inversion/5).
POST	/api/payment/checkout/generico	authenticate	paymentController.createCheckoutGenerico	Flujo avanzado: Crea/Regenera una Transacción y Checkout.
POST	/api/payment/checkout	authenticate	paymentController.createCheckout	Flujo de compatibilidad (Inversiones).
GET	/api/payment/status/:id_transaccion	authenticate	paymentController.getPaymentStatus	Consulta el estado final de una transacción (con opción de refresco).
GET	/api/payment/redirect	N/A (Ruta de retorno de la pasarela)	paymentController.handleCheckoutRedirect	Redirige al usuario al frontend después del pago.
POST	/webhook/:metodo	N/A (Definida en el nivel más alto, ej., server.js)	paymentController.handleWebhook	Recepción de Webhooks de MP. Abierta al público (la seguridad se garantiza con la firma criptográfica).


Mapeo de Controladores: Gestión de Proyectos (proyecto.controller.js)
Este controlador maneja la creación y el mantenimiento de los proyectos de inversión, incluyendo la lógica compleja para vincular lotes y notificar a los usuarios sobre nuevos proyectos. Gran parte de la funcionalidad CRUD está restringida a administradores, mientras que las funciones de consulta de proyectos "activos" están disponibles para cualquier usuario autenticado.

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
findAllActivo	Obtiene todos los proyectos que están activos y visibles para inversión.	Llama a proyectoService.findAllActivo().	200 (OK).
findByIdActivo	Obtiene un proyecto específico, solo si está activo.	Llama a proyectoService.findByIdActivo(id).	200 (OK). 404 (Not Found).
findMyProjects	Obtiene una lista única de proyectos en los que el usuario ha invertido o está suscrito.	Lógica de combinación: Usa suscripcionProyectoService.findByUserId y inversionService.findByUserId.	200 (OK).
create	Crea un nuevo proyecto.	CRÍTICA: Ejecuta una Transacción de BD para asegurar la atomicidad de: 1. Creación del Proyecto. 2. Asociación de lotesIds al nuevo proyecto. 3. Envío de un mensaje de notificación general a todos los usuarios activos.	201 (Created). 400 (Bad Request).
update	Actualiza un proyecto existente.	Ejecuta una Transacción de BD para actualizar el proyecto y reasociar la lista de lotes (loteService.updateLotesProyecto).	200 (OK). 404 (Not Found).
softDelete	"Elimina" un proyecto (soft delete).	Llama a proyectoService.softDelete(id).	200 (OK). 404 (Not Found).
findAll	Obtiene todos los proyectos (incluye inactivos y eliminados lógicamente).	Llama a proyectoService.findAll(). Solo para Administradores.	200 (OK).
findById	Obtiene un proyecto por ID (incluye inactivos).	Llama a proyectoService.findById(id). Solo para Administradores.	200 (OK). 404 (Not Found).
endAuction	(Función de Lote) Finaliza la subasta de un lote de ese proyecto.	Llama a loteService.endAuction(id). (Lógica crítica de asignación de ganador).	200 (OK). 400 (Bad Request).


7.21. Mapeo de Endpoints: routes/proyecto.routes.js
El enrutamiento de proyectos se organiza para que las rutas de consumo masivo (/activos) estén definidas antes que las rutas dinámicas, lo que asegura un correcto enrutamiento. Las rutas de Administración requieren autenticación y la validación de rol (authorizeAdmin).

Método HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Propósito y Requisitos de Seguridad
GET	/api/proyectos/activos	authenticate	proyectoController.findAllActivo	Lista todos los proyectos activos para inversión (Consumo público).
POST	/api/proyectos/	authenticate -> authorizeAdmin	proyectoController.create	Creación de un nuevo proyecto. Requiere Admin.
GET	/api/proyectos/	authenticate -> authorizeAdmin	proyectoController.findAll	Lista todos los proyectos (CRUD Admin). Requiere Admin.
GET	/api/proyectos/:id/activo	authenticate	proyectoController.findByIdActivo	Obtiene un proyecto por ID, solo si está activo.
GET	/api/proyectos/:id	authenticate -> authorizeAdmin	proyectoController.findById	Obtiene cualquier proyecto por ID (CRUD Admin). Requiere Admin.
PUT	/api/proyectos/:id	authenticate -> authorizeAdmin	proyectoController.update	Actualización de proyecto. Requiere Admin.
DELETE	/api/proyectos/:id	authenticate -> authorizeAdmin	proyectoController.softDelete	Eliminación lógica de proyecto. Requiere Admin.

Mapeo de Controladores: Gestión de Pujas y Checkout 2FA (puja.controller.js)
Este controlador administra la funcionalidad de las pujas, desde su creación y consulta personal hasta el flujo de pago que se activa cuando un usuario resulta ganador de una subasta y debe pagar el lote.

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
create	Crea una nueva puja en un lote activo.	Llama a pujaService.create(), asegurando que la puja se asigne al req.user.id.	201 (Created). 400 (Monto/Lote inválido).
requestCheckout	Inicia el proceso de pago para una puja ganadora.	Bifurcación 2FA: Si el usuario tiene 2FA activo, devuelve 202 solicitando el código. Si no, genera el checkout llamando a pujaService.requestCheckoutForPuja().	200 (Redirección). 202 (2FA Requerido). 403 (No autorizado). 409 (Puja no está en estado "ganadora pendiente").
confirmarPujaCon2FA	Verifica el código 2FA y, si es correcto, continúa con el checkout de la puja.	CRÍTICA: Llama a auth2faService.verifyToken(). Si la verificación es exitosa, llama a pujaService.requestCheckoutForPuja() para generar la Transacción.	200 (Redirección). 401 (Código 2FA incorrecto). 403 (2FA no activo).
manageAuctionEnd	Función interna de administración para ejecutar la lógica final de una subasta.	Llama a pujaService.gestionarTokensAlFinalizar(id_lote) para gestionar los tokens y la asignación final del lote. Solo para Administradores.	200 (OK). 400 (Datos faltantes).
findMyPujas	Obtiene todas las pujas que el usuario autenticado ha realizado.	Llama a pujaService.findByUserId(userId).	200 (OK).
findAllActivo	Obtiene todas las pujas activas en la plataforma.	Llama a pujaService.findAllActivo().	200 (OK).
findAll	Obtiene todas las pujas del sistema.	Llama a pujaService.findAll(). Solo para Administradores.	200 (OK).
CRUD Genérico/Mi Puja	Funciones CRUD para Administradores o para acciones específicas del usuario (findMyPujaById, softDeleteMyPuja, etc.).	Realizan operaciones básicas de consulta/modificación, validando la propiedad en el caso de las rutas de usuario.	200 (OK) / 204 (No Content) / 404 (Not Found).


7.23. Mapeo de Endpoints: routes/puja.routes.js
El orden de las rutas es especialmente sensible aquí para priorizar las rutas del usuario (/mis_pujas) y los flujos de checkout antes de que el parámetro dinámico :id general capture las peticiones.

Método HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Propósito y Requisitos de Seguridad
POST	/api/pujas/	authenticate	pujaController.create	Crea una nueva puja.
GET	/api/pujas/activas	authenticate	pujaController.findAllActivo	Lista todas las pujas que están en subastas activas.
GET	/api/pujas/mis_pujas	authenticate	pujaController.findMyPujas	Lista las pujas del usuario autenticado.
GET	/api/pujas/mis_pujas/:id	authenticate	pujaController.findMyPujaById	Obtiene una puja específica del usuario.
DELETE	/api/pujas/mis_pujas/:id	authenticate	pujaController.softDeleteMyPuja	Elimina una puja del usuario.
POST	/api/pujas/iniciar-pago/:id	authenticate	pujaController.requestCheckout	Paso 1 Checkout: Inicia el pago de la puja ganadora y gestiona la bifurcación 2FA.
POST	/api/pujas/confirmar-2fa	authenticate	pujaController.confirmarPujaCon2FA	Paso 2 Checkout: Verifica el código 2FA y continúa con la generación del checkout.
GET	/api/pujas/	authenticate -> authorizeAdmin	pujaController.findAll	Lista todas las pujas (Admin).
POST	/api/pujas/gestionar_finalizacion	authenticate -> authorizeAdmin	pujaController.manageAuctionEnd	Punto de control para gestionar tokens al finalizar subasta. Requiere Admin.
GET	/api/pujas/:id	authenticate -> authorizeAdmin	pujaController.findById	Obtiene una puja por ID (Admin).
PUT	/api/pujas/:id	authenticate -> authorizeAdmin	pujaController.update	Actualiza una puja por ID (Admin).
DELETE	/api/pujas/:id	authenticate -> authorizeAdmin	pujaController.softDelete	Elimina una puja por ID (Admin).

Mapeo de Controladores: Redirección Post-Pago (redireccion.controller.js)
Este controlador se encarga de recibir las peticiones de retorno (GET) enviadas por la pasarela de pago después de que el usuario interactúa con ella. Su única función es actualizar el estado de la transacción si es un fallo/cancelación y redirigir al usuario al frontend con el estado correspondiente.

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
handleFailure	Procesa el retorno del usuario por fallo o cancelación de la operación de pago.	CRÍTICA: Llama a transaccionService.cancelarTransaccionPorUsuario(id) para marcar la transacción interna como fallido. Redirige al frontend (/payment-result/:id?status=failure).	302 (Redirect) a Frontend URL.
handleSuccess	Procesa el retorno del usuario por éxito en la pasarela.	Asunción: El estado final de pagado se actualizará por el Webhook (proceso asíncrono y seguro). Esta función solo redirige al usuario a la vista de éxito (/payment-result/:id?status=success).	302 (Redirect) a Frontend URL.
handlePending	Procesa el retorno del usuario por estado pendiente en la pasarela.	Redirige al usuario a la vista de estado pendiente, sugiriendo la consulta de estado posterior (/payment-result/:id?status=pending).	302 (Redirect) a Frontend URL.


7.25. Mapeo de Endpoints: Redirección (redireccion.routes.js)
Estas rutas son públicas y deben estar expuestas directamente para que la pasarela de pago pueda enviar el navegador del usuario de vuelta al servidor tras completar la interacción.

Método HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Propósito y Requisitos de Seguridad
GET	/pago/exito/:id	N/A (Público)	redireccionController.handleSuccess	Retorno de pasarela en caso de éxito.
GET	/pago/fallo/:id	N/A (Público)	redireccionController.handleFailure	Retorno de pasarela en caso de fallo o cancelación por el usuario.
GET	/pago/pendiente/:id	N/A (Público)	redireccionController.handlePending	Retorno de pasarela en caso de que el pago quede en proceso (ej. efectivo).


 Mapeo de Controladores: Resumen de Cuenta (resumen_cuenta.controller.js)
Este controlador es responsable de generar los resúmenes detallados de las cuentas de inversión/suscripción, calcular las cuotas mensuales (basadas en valores dinámicos como el cemento) y proporcionar acceso a los usuarios a sus propios resúmenes, mientras reserva el control CRUD completo para los administradores.

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
create	Creación y Cálculo: Crea un nuevo resumen de cuenta.	CRÍTICA: Depende de cuotaMensualService.createAndSetProjectAmount para calcular el valor móvil y el valor mensual final basado en el precio del cemento y los porcentajes de plan/IVA. Crea el ResumenCuenta con estos detalles.	201 (Created). 404 (Proyecto no encontrado). 500 (Error de cálculo/BD).
findMyAccountSummaries	Obtiene todos los resúmenes de cuenta del usuario autenticado.	Llama a resumenCuentaService.getAccountSummariesByUserId(userId).	200 (OK).
findAll	Obtiene todos los resúmenes de cuenta del sistema.	Llama a resumenCuentaService.findAll(). Solo para Administradores.	200 (OK).
getAccountSummaryById	Obtiene un resumen específico.	Control de Acceso: Verifica si el usuario es Administrador (acceso total) o si es el propietario del resumen (findResumenByIdAndUserId).	200 (OK). 404 (No encontrado o no autorizado).
update	Actualiza manualmente un resumen de cuenta.	Llama a resumenCuentaService.update(). Solo para Administradores.	200 (OK). 404 (Not Found).
softDelete	Elimina lógicamente un resumen de cuenta.	Llama a resumenCuentaService.softDelete(). Solo para Administradores.	200 (OK). 404 (Not Found).


7.27. Mapeo de Endpoints: Resumen de Cuenta (resumen_cuenta.routes.js)
Las rutas están diseñadas para diferenciar claramente entre el acceso del usuario final (lectura de sus resúmenes) y las operaciones de administración (CRUD total), utilizando authMiddleware.authorizeAdmin.

Método HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Propósito y Requisitos de Seguridad
GET	/api/resumen_cuenta/mis_resumenes	authenticate	resumenCuentaController.findMyAccountSummaries	Obtiene la lista de resúmenes del usuario. (Lectura para el cliente).
GET	/api/resumen_cuenta/	authenticate -> authorizeAdmin	resumenCuentaController.findAll	Lista todos los resúmenes (CRUD Admin). Requiere Admin.
GET	/api/resumen_cuenta/:id	authenticate	resumenCuentaController.getAccountSummaryById	Obtiene un resumen específico, verificando la propiedad o el rol de Admin.
PUT	/api/resumen_cuenta/:id	authenticate -> authorizeAdmin	resumenCuentaController.update	Actualiza un resumen por ID. Requiere Admin.
DELETE	/api/resumen_cuenta/:id	authenticate -> authorizeAdmin	resumenCuentaController.softDelete	Eliminación lógica de un resumen. Requiere Admin.

Mapeo de Controladores: Suscripción de Proyecto (suscripcion_proyecto.controller.js)
Este controlador maneja el proceso de suscripción a un proyecto de inversión, desde el pago inicial (con validación 2FA) hasta la creación del registro de la suscripción y su posterior gestión.

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
iniciarSuscripcion	Inicia la transacción de pago para la inversión inicial del proyecto.	CRÍTICA (Transacción y 2FA): 1. Verifica si el proyecto es válido. 2. Si el usuario tiene 2FA activo, crea la Transacción y el Pago como pendiente en una transacción de BD, y devuelve 202 (requiere 2FA). 3. Si no hay 2FA, genera la URL de checkout de la pasarela y devuelve 200 con la URL.	200 (Redirección). 202 (2FA Requerido). 400 (Proyecto finalizado). 404 (Proyecto no encontrado).
confirmarSuscripcionCon2FA	Verifica el código 2FA para un pago de suscripción pendiente.	CRÍTICA: Llama a auth2faService.verifyToken. Si es exitoso, llama a TransaccionService.generarCheckoutParaTransaccionExistente para crear la preferencia de pago y devolver la URL de redirección.	200 (Redirección). 401 (Código 2FA incorrecto). 403 (Transacción inválida/no pertenece).
confirmarSuscripcion	Endpoint Webhook llamado por la pasarela de pago para notificar el pago exitoso.	CRÍTICA: Llama a suscripcionProyectoService.confirmarSuscripcion(transaccionId). Esta función es responsable de crear el registro de la suscripción y el Resumen de Cuenta (si aplica) una vez que el pago ha sido validado por el webhook.	200 (OK - respuesta al webhook). 400 (ID de transacción faltante).
findMySubscriptions	Obtiene todas las suscripciones activas del usuario.	Llama a suscripcionProyectoService.findByUserId(userId).	200 (OK).
findMySubscriptionById	Obtiene una suscripción específica del usuario.	Llama a suscripcionProyectoService.findByIdAndUserId(id, userId).	200 (OK). 404 (No encontrada o no pertenece).
softDeleteMySubscription	Cancela (soft delete) una suscripción del usuario.	Verifica que la suscripción pertenezca al usuario antes de llamar a suscripcionProyectoService.softDelete().	200 (OK). 404 (No encontrada o no pertenece).
findAll / findById	Funciones CRUD para administradores.	Acceso completo a todas las suscripciones. Requiere Admin.	200 (OK). 404 (Not Found).


7.29. Mapeo de Endpoints: Suscripción de Proyecto (suscripcion_proyecto.routes.js)
Las rutas reflejan el flujo de pago con 2FA y separan claramente los accesos de usuario (/mis_suscripciones) de las funcionalidades de administración.

Método HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Propósito y Requisitos de Seguridad
POST	/api/suscripciones/iniciar-pago	authenticate	suscripcionProyectoController.iniciarSuscripcion	Paso 1 Checkout: Inicia la transacción de pago y gestiona la bifurcación 2FA.
POST	/api/suscripciones/confirmar-2fa	authenticate	suscripcionProyectoController.confirmarSuscripcionCon2FA	Paso 2 Checkout: Verifica el código 2FA y genera la URL de redirección.
GET	/api/suscripciones/activas	authenticate	suscripcionProyectoController.findAllActivo	Lista las suscripciones activas a proyectos.
GET	/api/suscripciones/mis_suscripciones	authenticate	suscripcionProyectoController.findMySubscriptions	Lista las suscripciones del usuario.
GET	/api/suscripciones/mis_suscripciones/:id	authenticate	suscripcionProyectoController.findMySubscriptionById	Obtiene una suscripción específica del usuario.
DELETE	/api/suscripciones/mis_suscripciones/:id	authenticate	suscripcionProyectoController.softDeleteMySubscription	Cancela una suscripción del usuario.
POST	/api/suscripciones/confirmar-pago	N/A (Público)	suscripcionProyectoController.confirmarSuscripcion	Webhook: Punto de entrada para la pasarela de pago para confirmar pagos.
GET	/api/suscripciones/	authenticate -> authorizeAdmin	suscripcionProyectoController.findAll	Lista todas las suscripciones (Admin).
GET	/api/suscripciones/:id	authenticate -> authorizeAdmin	suscripcionProyectoController.findById	Obtiene una suscripción por ID (Admin).
DELETE	/api/suscripciones/:id	authenticate -> authorizeAdmin	suscripcionProyectoController.softDelete	Eliminación lógica de una suscripción (Admin).


Mapeo de Controladores: Gestión de Suscripciones Genéricas (suscripcion.controller.js)
Este controlador está diseñado para una única tarea: permitir que un usuario autenticado cancele una suscripción existente, asegurando que solo pueda modificar su propia información.

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
cancel	Permite a un usuario realizar una eliminación lógica (soft delete) de su propia suscripción.	Control de Acceso: Realiza una verificación estricta para asegurar que el id_usuario de la suscripción coincida con el req.user.id del usuario autenticado. Llama a suscripcionService.softDelete(id).	200 (OK). 403 (Acceso denegado: no es el propietario). 400 (Error de servicio).


7.31. Mapeo de Endpoints: Suscripción Genérica (suscripcion.routes.js)
Esta sección define el único endpoint expuesto por este módulo, que es un verbo específico (/cancelar) para evitar conflictos con las rutas CRUD genéricas de otros controladores.

Método HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Propósito y Requisitos de Seguridad
PUT	/api/suscripciones/:id/cancelar	authenticate	suscripcionController.cancel	Permite al usuario cancelar su suscripción específica (:id). Requiere Autenticación y la validación de propiedad interna.


Mapeo de Controladores: Transacciones y Flujo de Pago (transaccion.controller.js)
Este controlador se centra en la gestión y consulta de los registros de transacciones. Su función más crítica es confirmarTransaccion, que asegura que el cambio de estado de una transacción y sus efectos asociados (como crear suscripciones o cerrar pujas) sean atómicos.

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
create	Crea una nueva transacción.	Llama a transaccionService.create(). Aunque existe, las transacciones se crean principalmente como parte de flujos mayores (suscripciones, pujas).	201 (Created). 400 (Datos inválidos).
confirmarTransaccion	CRÍTICO: Procesa y confirma una transacción como pagada (usado por webhooks o Administrador).	Envuelve el proceso en una transacción de Sequelize (t) para garantizar que, si falla alguna actualización subsiguiente (ej. crear una suscripción), todo se revierta (t.rollback()). Llama a transaccionService.confirmarTransaccion().	200 (OK). 400 (Error de lógica o servicio).
findMyTransactions	Obtiene todas las transacciones del usuario autenticado.	Llama a transaccionService.findByUserId(userId).	200 (OK).
findMyTransactionById	Obtiene una transacción específica del usuario.	Llama a transaccionService.findByIdAndUserId(id, userId), validando la propiedad.	200 (OK). 404 (No encontrada o no pertenece).
findAll	Obtiene todas las transacciones del sistema.	Llama a transaccionService.findAll(). Solo para Administradores.	200 (OK).
CRUD Genérico	Funciones CRUD para Administradores.	findById, update, softDelete. Permiten la gestión completa por parte de un usuario con rol Admin.	200 (OK) / 204 (No Content). 404 (Not Found).


7.33. Mapeo de Endpoints: Transacción (transaccion.routes.js)
Las rutas están organizadas para priorizar las consultas del usuario final (/mis_transacciones) antes de exponer las rutas dinámicas para la administración.

Método HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Propósito y Requisitos de Seguridad
GET	/api/transacciones/	authenticate -> authorizeAdmin	transaccionController.findAll	Lista todas las transacciones del sistema. Requiere Admin.
PUT	/api/transacciones/:id/confirmar	authenticate -> authorizeAdmin	transaccionController.confirmarTransaccion	Ruta de administrador para forzar la confirmación de una transacción.
GET	/api/transacciones/mis_transacciones	authenticate	transaccionController.findMyTransactions	Obtiene la lista de transacciones del usuario.
GET	/api/transacciones/mis_transacciones/:id	authenticate	transaccionController.findMyTransactionById	Obtiene una transacción específica del usuario, validando la propiedad.
PUT	/api/transacciones/mis_transacciones/:id	authenticate	transaccionController.updateMyTransaction	Permite al usuario actualizar su propia transacción (si aplica).
GET	/api/transacciones/:id	authenticate -> authorizeAdmin	transaccionController.findById	Obtiene una transacción por ID (Admin).
PUT	/api/transacciones/:id	authenticate -> authorizeAdmin	transaccionController.update	Actualiza una transacción por ID (Admin).
DELETE	/api/transacciones/:id	authenticate -> authorizeAdmin	transaccionController.softDelete	Eliminación lógica de una transacción por ID (Admin).

Mapeo de Controladores: Usuarios y Autenticación (usuario.controller.js)
Este controlador administra la funcionalidad central de la plataforma, incluyendo el registro, la gestión del perfil propio del usuario (/me) y la capacidad de los administradores para realizar el CRUD completo sobre todos los usuarios.

Función del Controlador	Propósito Principal	Lógica Crítica y Servicios Utilizados	Códigos de Respuesta Clave para el Frontend
create	Registra un nuevo usuario.	Llama a usuarioService.create(). El servicio maneja el hashing de la contraseña y la generación del token de confirmación de email. Oculta datos sensibles en la respuesta.	201 (Created). 400 (Validación fallida, ej: email duplicado).
confirmEmail	Activa la cuenta de un usuario mediante el token recibido por correo.	Llama a usuarioService.confirmEmail(token). Actualiza email_confirmado: true.	200 (Éxito). 400 (Token inválido o expirado).
findMe	Obtiene la información del perfil del usuario autenticado.	Usa req.user.id para buscar el perfil.	200 (OK). 404 (Usuario no encontrado).
updateMe	Actualiza la información del perfil del usuario autenticado.	Usa req.user.id para actualizar.	200 (OK). 400 (Validación fallida).
softDeleteMe	Inhabilita la cuenta del usuario autenticado (Soft Delete).	Llama a usuarioService.softDelete(req.user.id).	204 (No Content).
findAll	Obtiene la lista completa de todos los usuarios (activos e inactivos).	Llama a usuarioService.findAll(). Solo para Administradores.	200 (OK).
findAllActivo	Obtiene la lista de usuarios con cuenta activa (activo: true).	Llama a usuarioService.findAllActivo(). Solo para Administradores.	200 (OK).
CRUD Admin	findById, update, softDelete.	Permite la gestión completa de cualquier usuario por su ID. Requiere rol Admin.	200 (OK) / 204 (No Content). 404 (Not Found).


7.35. Mapeo de Endpoints: Usuarios y Seguridad (usuario.routes.js)
El orden de las rutas es crítico para evitar que las rutas estáticas (/confirmar, /me, /activos) sean interpretadas erróneamente como un ID (/:id).

Método HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Propósito y Requisitos de Seguridad
POST	/api/usuarios/	N/A (Público)	usuarioController.create	Registro de nuevo usuario.
GET	/api/usuarios/confirmar/:token	N/A (Público)	usuarioController.confirmEmail	Enlace de activación por correo electrónico.
GET	/api/usuarios/me	authenticate	usuarioController.findMe	Obtener perfil del usuario autenticado.
PUT	/api/usuarios/me	authenticate	usuarioController.updateMe	Actualizar perfil del usuario autenticado.
DELETE	/api/usuarios/me	authenticate	usuarioController.softDeleteMe	Desactivar/Eliminar perfil propio.
GET	/api/usuarios/	authenticate -> authorizeAdmin	usuarioController.findAll	Lista todos los usuarios. Requiere Admin.
GET	/api/usuarios/activos	authenticate -> authorizeAdmin	usuarioController.findAllActivo	Lista solo usuarios activos. Requiere Admin.
GET	/api/usuarios/:id	authenticate -> authorizeAdmin	usuarioController.findById	Obtiene un usuario por ID. Requiere Admin.
PUT	/api/usuarios/:id	authenticate -> authorizeAdmin	usuarioController.update	Actualiza un usuario por ID. Requiere Admin.
DELETE	/api/usuarios/:id	authenticate -> authorizeAdmin	usuarioController.softDelete	Eliminación lógica de un usuario por ID. Requiere Admin.
















