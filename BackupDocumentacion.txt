# üé® Gu√≠a COMPLETA de Integraci√≥n Frontend - Nect√°rea API

## üöÄ PASO A PASO DESDE CERO - Para Desarrolladores Frontend

Esta gu√≠a asume que **NO sabes nada** sobre el backend de Nect√°rea. Vamos a explicar TODO desde cero.


---

## ‚ùì ¬øQu√© es esta API?

Nect√°rea es una plataforma de **crowdfunding** (como Kickstarter) donde:

- Los usuarios pueden **invertir** en proyectos
- Los usuarios pueden hacer **pujas** (como subastas)
- Los usuarios pueden **suscribirse** a proyectos mensuales
- Todo se paga con **Mercado Pago**

La API es el backend que maneja toda la l√≥gica y la base de datos.

---

## üìö Antes de Empezar

### ¬øQu√© necesitas saber?

- ‚úÖ JavaScript b√°sico
- ‚úÖ Conceptos de HTTP (GET, POST, PUT, DELETE)
- ‚úÖ JSON
- ‚úÖ React/Vue/Angular (cualquier framework frontend)

### ¬øQu√© NO necesitas saber?

- ‚ùå Node.js o Express (el backend ya est√° hecho)
- ‚ùå PostgreSQL (la base de datos ya est√° configurada)
- ‚ùå C√≥mo funcionan los webhooks internamente

### Herramientas Requeridas

- **Node.js** v18+ (para correr el backend localmente)
- **PostgreSQL** v14+ (base de datos)
- **Git** (para clonar el repositorio)
- **Postman** o **Thunder Client** (para probar la API)

---

## üîß PASO 1: Configuraci√≥n del Backend

### 1.1 Clonar el Repositorio

```bash
# Abre tu terminal y ejecuta:
git clone https://github.com/SebastianASU2005/Nectarea_BD.git
cd Nectarea_BD
```

### 1.2 Instalar Dependencias

```bash
npm install
```

‚è≥ Esto tomar√° unos minutos. Est√° instalando todas las librer√≠as necesarias.

### 1.3 Instalar y Configurar PostgreSQL

#### En Windows:

1. Descarga PostgreSQL: https://www.postgresql.org/download/windows/
2. Instala con los valores por defecto
3. Durante la instalaci√≥n, anota la contrase√±a que elijas (la necesitar√°s)
4. Puerto por defecto: **5432**

#### En Mac:

```bash
brew install postgresql@14
brew services start postgresql@14
```

#### En Linux (Ubuntu/Debian):

```bash
sudo apt update
sudo apt install postgresql postgresql-contrib
sudo systemctl start postgresql
```

### 1.4 Crear la Base de Datos

Abre tu terminal y ejecuta:

```bash
# Conectarse a PostgreSQL
psql -U postgres

# Dentro de psql, ejecuta:
CREATE DATABASE nectarea_dev;
CREATE USER nectarea_user WITH PASSWORD 'dev_password_123';
GRANT ALL PRIVILEGES ON DATABASE nectarea_dev TO nectarea_user;

# Salir de psql
\q
```

‚úÖ **Importante:** Anota estos datos, los necesitar√°s en el siguiente paso.

### 1.5 Configurar Variables de Entorno

Crea un archivo `.env` en la ra√≠z del proyecto:

```bash
# En la carpeta Nectarea_BD/, crea el archivo .env
touch .env
```

Abre `.env` con tu editor favorito y copia esto:

```env
# === ENTORNO ===
NODE_ENV=development

# === SERVIDOR ===
PORT=3000
HOST_URL=http://localhost:3000
FRONTEND_URL=http://localhost:5173

# === BASE DE DATOS ===
DB_HOST=localhost
DB_PORT=5432
DB_NAME=nectarea_dev
DB_USER=nectarea_user
DB_PASSWORD=dev_password_123
DB_DIALECT=postgres

# === JWT (AUTENTICACI√ìN) ===
JWT_SECRET=mi_secreto_super_seguro_de_desarrollo_cambiar_en_produccion
JWT_EXPIRES_IN=7d

# === MERCADO PAGO (MODO PRUEBA) ===
# Deja estos valores vac√≠os por ahora, los configuraremos despu√©s
MP_ACCESS_TOKEN=
MP_WEBHOOK_SECRET=
MP_CURRENCY_ID=ARS

# === EMAIL (OPCIONAL EN DESARROLLO) ===
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_SECURE=false
EMAIL_USER=
EMAIL_PASSWORD=
EMAIL_FROM=noreply@nectarea.com
```

‚ö†Ô∏è **MUY IMPORTANTE:**

- Usa los mismos valores que creaste en el paso 1.4
- Si tu contrase√±a de PostgreSQL es diferente, c√°mbiala en `DB_PASSWORD`
- Si usas otro puerto, c√°mbialo en `DB_PORT`

### 1.6 Inicializar la Base de Datos

```bash
npm run migrate
```

Esto crear√° todas las tablas autom√°ticamente. Ver√°s mensajes como:

```
Executing (default): CREATE TABLE IF NOT EXISTS "usuarios"...
Executing (default): CREATE TABLE IF NOT EXISTS "proyectos"...
‚úÖ Base de datos sincronizada
```

### 1.7 Iniciar el Backend

```bash
npm run dev
```

Deber√≠as ver:

```
‚úÖ Conectado a la base de datos PostgreSQL
‚úÖ Servidor corriendo en http://localhost:3000
‚úÖ Mercado Pago SDK configurado (o ‚ö†Ô∏è si no configuraste MP a√∫n)
```

### 1.8 Verificar que Funciona

Abre tu navegador y ve a:

```
http://localhost:3000/api/health
```

Deber√≠as ver:

```json
{
  "status": "ok",
  "timestamp": "2025-10-15T10:30:00.000Z"
}
```

‚úÖ **¬°Perfecto! El backend est√° corriendo.**

---

## ‚öôÔ∏è PASO 2: Configuraci√≥n del Frontend

### 2.1 Crear Tu Proyecto Frontend

```bash
# Si usas React con Vite:
npm create vite@latest nectarea-frontend -- --template react
cd nectarea-frontend
npm install

# Si usas Vue:
npm create vite@latest nectarea-frontend -- --template vue
cd nectarea-frontend
npm install
```

### 2.2 Instalar Axios (Para Comunicarte con la API)

```bash
npm install axios
```

### 2.3 Crear el Archivo de Configuraci√≥n de la API

Crea un archivo: `src/services/api.js`

```javascript
// src/services/api.js
import axios from "axios";

// URL del backend (c√°mbialo seg√∫n tu entorno)
const API_URL = import.meta.env.VITE_API_URL || "http://localhost:3000/api";

// Crear instancia de axios con configuraci√≥n base
const apiClient = axios.create({
  baseURL: API_URL,
  timeout: 15000, // 15 segundos
  headers: {
    "Content-Type": "application/json",
  },
});

// ============================================
// INTERCEPTOR DE REQUEST (Agrega el token autom√°ticamente)
// ============================================
apiClient.interceptors.request.use(
  (config) => {
    // Obtener el token del localStorage
    const token = localStorage.getItem("token");

    // Si existe, agregarlo al header
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }

    console.log(`üì§ ${config.method.toUpperCase()} ${config.url}`);
    return config;
  },
  (error) => {
    console.error("‚ùå Error en request:", error);
    return Promise.reject(error);
  }
);

// ============================================
// INTERCEPTOR DE RESPONSE (Maneja errores autom√°ticamente)
// ============================================
apiClient.interceptors.response.use(
  (response) => {
    console.log(`‚úÖ Respuesta recibida de ${response.config.url}`);
    return response;
  },
  (error) => {
    if (error.response) {
      const { status } = error.response;

      // Si el token expir√≥ o es inv√°lido
      if (status === 401) {
        console.error("üö´ Token inv√°lido o expirado");
        localStorage.removeItem("token");
        localStorage.removeItem("user");
        window.location.href = "/login";
      }

      // Si no tiene permisos
      if (status === 403) {
        console.error("üö´ No tienes permisos para esta acci√≥n");
      }
    } else if (error.request) {
      console.error("‚ùå No se pudo conectar con el servidor");
    }

    return Promise.reject(error);
  }
);

export default apiClient;
```

### 2.4 Crear Variables de Entorno del Frontend

Crea un archivo `.env` en la ra√≠z de tu proyecto frontend:

```env
VITE_API_URL=http://localhost:3000/api
```

### 2.5 Probar la Conexi√≥n

Crea un archivo: `src/services/authService.js`

```javascript
// src/services/authService.js
import apiClient from "./api";

// Funci√≥n de prueba
export const testConnection = async () => {
  try {
    const response = await apiClient.get("/health");
    console.log("‚úÖ Conexi√≥n exitosa:", response.data);
    return response.data;
  } catch (error) {
    console.error("‚ùå Error de conexi√≥n:", error);
    throw error;
  }
};
```

Ahora, en tu componente principal (App.jsx o similar):

```jsx
import { useEffect } from "react";
import { testConnection } from "./services/authService";

function App() {
  useEffect(() => {
    testConnection();
  }, []);

  return <div>Nect√°rea Frontend</div>;
}

export default App;
```

Inicia tu frontend:

```bash
npm run dev
```

Abre la consola del navegador (F12) y deber√≠as ver:

```
üì§ GET /health
‚úÖ Respuesta recibida de /health
‚úÖ Conexi√≥n exitosa: { status: 'ok', timestamp: '...' }
```

‚úÖ **¬°Perfecto! Tu frontend se comunica con el backend.**

---

## üöÄ PASO 3: Entendiendo los Modelos de Base de Datos

### ¬øQu√© es un Modelo?

Un **Modelo** es la representaci√≥n en c√≥digo de una **tabla** en la base de datos (DB), utilizando Sequelize. Define las columnas, los tipos de datos y las restricciones.

| Modelo (Sequelize)    | Tabla (DB)             | Prop√≥sito Principal                                             |
| :-------------------- | :--------------------- | :-------------------------------------------------------------- |
| `Usuario`             | `usuario`              | Gesti√≥n de cuentas de usuario.                                  |
| `Proyecto`            | `proyecto`             | Detalles y estado de los proyectos de inversi√≥n.                |
| `Transaccion`         | `transaccion`          | Registro central de flujos de dinero.                           |
| `SuscripcionProyecto` | `suscripcion_proyecto` | V√≠nculo y estado de la suscripci√≥n de un usuario a un proyecto. |
| `Puja`                | `puja`                 | Registro de las ofertas en las subastas de lotes.               |

---

### Modelos Principales del Sistema

#### 1. Usuario (`usuario`)

| Atributo             | Tipo de Dato  | Observaciones Clave                                          |
| :------------------- | :------------ | :----------------------------------------------------------- |
| **`id`**             | `INTEGER`     | Clave primaria.                                              |
| `nombre`, `apellido` | `STRING(100)` |                                                              |
| **`email`**          | `STRING(255)` | √önico.                                                       |
| **`dni`**            | `STRING(20)`  | √önico.                                                       |
| `nombre_usuario`     | `STRING(50)`  | √önico.                                                       |
| `contrase√±a_hash`    | `STRING(255)` | Clave hasheada.                                              |
| **`rol`**            | `ENUM`        | Opciones: **`"admin"`, `"cliente"`** (Defecto: `"cliente"`). |
| **`activo`**         | `BOOLEAN`     | **Define si la cuenta est√° activa** (Defecto: `false`).      |
| `confirmado_email`   | `BOOLEAN`     | Indica si el email ha sido verificado.                       |
| `is_2fa_enabled`     | `BOOLEAN`     | Indica si la Autenticaci√≥n de Dos Factores est√° activa.      |
| `twofa_secret`       | `STRING(255)` | Clave secreta para TOTP/2FA.                                 |

<br>

#### 2. Proyecto (`proyecto`)

| Atributo                       | Tipo de Dato     | Observaciones Clave                                          |
| :----------------------------- | :--------------- | :----------------------------------------------------------- |
| **`id`**                       | `INTEGER`        | Clave primaria.                                              |
| `nombre_proyecto`              | `STRING(255)`    |                                                              |
| `descripcion`                  | `TEXT`           |                                                              |
| **`tipo_inversion`**           | `ENUM`           | Opciones: **`"directo"`, `"mensual"`**.                      |
| `monto_inversion`              | `DECIMAL(18, 2)` | El monto objetivo de inversi√≥n.                              |
| **`estado_proyecto`**          | `ENUM`           | Opciones: **`"En Espera"`, `"En proceso"`, `"Finalizado"`**. |
| `suscripciones_actuales`       | `INTEGER`        | Contador de suscripciones activas.                           |
| `fecha_inicio`, `fecha_cierre` | `DATEONLY`       |                                                              |
| `pack_de_lotes`                | `BOOLEAN`        | Indica si el proyecto gestiona subastas de lotes.            |

<br>

#### 3. Transacci√≥n (`transaccion`)

| Atributo                 | Tipo de Dato     | Observaciones Clave                                                    |
| :----------------------- | :--------------- | :--------------------------------------------------------------------- |
| **`id`**                 | `INTEGER`        | Clave primaria.                                                        |
| `id_usuario`             | `INTEGER`        | Usuario que realiza la transacci√≥n.                                    |
| `monto`                  | `DECIMAL(15, 2)` | Monto de la transacci√≥n.                                               |
| `tipo_transaccion`       | `STRING(50)`     | Tipo de transacci√≥n (e.g., "Inversion", "Puja", "PagoMensual").        |
| **`estado_transaccion`** | `ENUM`           | Opciones: **`"pendiente"`, `"pagado"`, `"fallido"`, `"reembolsado"`**. |
| `id_pago_mensual`        | `INTEGER`        | **FK a la tabla `Pago`** (Pago de mensualidad).                        |
| `id_pago_pasarela`       | `INTEGER`        | **FK a la tabla `PagoMercado`** (Pago v√≠a pasarela).                   |
| `id_inversion`           | `INTEGER`        | FK a `Inversion` (si aplica).                                          |
| `id_puja`                | `INTEGER`        | FK a `Puja` (si aplica).                                               |

<br>

#### 4. PagoMercado (`pagos_mercado`)

| Atributo                  | Tipo de Dato     | Observaciones Clave                                                                     |
| :------------------------ | :--------------- | :-------------------------------------------------------------------------------------- |
| **`id`**                  | `INTEGER`        | Clave primaria.                                                                         |
| **`id_transaccion`**      | `INTEGER`        | **FK a la tabla `Transaccion`**.                                                        |
| `id_transaccion_pasarela` | `STRING`         | ID √∫nico en la pasarela (e.g., Mercado Pago ID).                                        |
| `monto_pagado`            | `DECIMAL(10, 2)` | Monto real pagado a trav√©s de la pasarela.                                              |
| `metodo_pasarela`         | `STRING`         | e.g., `"mercadopago"`, `"stripe"`.                                                      |
| **`estado`**              | `ENUM`           | Opciones: **`"pendiente"`, `"aprobado"`, `"rechazado"`, `"devuelto"`, `"en_proceso"`**. |
| `detalles_raw`            | `JSON`           | Objeto completo del webhook/API.                                                        |

<br>

#### 5. SuscripcionProyecto (`suscripcion_proyecto`)

| Atributo             | Tipo de Dato     | Observaciones Clave                          |
| :------------------- | :--------------- | :------------------------------------------- |
| **`id`**             | `INTEGER`        | Clave primaria.                              |
| `id_usuario`         | `INTEGER`        | Usuario suscrito.                            |
| `id_proyecto`        | `INTEGER`        | Proyecto suscrito.                           |
| **`meses_a_pagar`**  | `INTEGER`        | Cantidad de meses que el usuario debe pagar. |
| `tokens_disponibles` | `INTEGER`        | Tokens acumulados para pujas (Defecto: `1`). |
| `saldo_a_favor`      | `DECIMAL(15, 2)` | Saldo proveniente de pagos excedentes.       |

<br>

#### 6. Pago (de Suscripci√≥n) (`pago`)

| Atributo             | Tipo de Dato     | Observaciones Clave                                                                         |
| :------------------- | :--------------- | :------------------------------------------------------------------------------------------ |
| **`id`**             | `INTEGER`        | Clave primaria.                                                                             |
| **`id_suscripcion`** | `INTEGER`        | Suscripci√≥n a la que pertenece el pago.                                                     |
| `id_usuario`         | `INTEGER`        | Usuario responsable del pago.                                                               |
| `id_proyecto`        | `INTEGER`        | Proyecto asociado.                                                                          |
| `monto`              | `DECIMAL(15, 2)` | Monto a pagar por la cuota.                                                                 |
| `fecha_vencimiento`  | `DATEONLY`       |                                                                                             |
| **`estado_pago`**    | `ENUM`           | Opciones: **`"pendiente"`, `"pagado"`, `"vencido"`, `"cancelado"`, `"cubierto_por_puja"`**. |
| `mes`                | `INTEGER`        | Mes de la cuota.                                                                            |

---

### Modelos de Subasta

#### 7. Lote (`lote`)

| Atributo                     | Tipo de Dato     | Observaciones Clave                                       |
| :--------------------------- | :--------------- | :-------------------------------------------------------- |
| **`id`**                     | `INTEGER`        | Clave primaria.                                           |
| `id_proyecto`                | `INTEGER`        | Proyecto al que pertenece.                                |
| `nombre_lote`                | `STRING(255)`    | Nombre del lote.                                          |
| `precio_base`                | `DECIMAL(10, 2)` | Precio m√≠nimo para la subasta.                            |
| **`estado_subasta`**         | `ENUM`           | Opciones: **`"pendiente"`, `"activa"`, `"finalizada"`**.  |
| `id_ganador`                 | `INTEGER`        | ID del usuario ganador.                                   |
| **`intentos_fallidos_pago`** | `INTEGER`        | Contador de incumplimientos de pago del ganador (m√°x. 3). |
| `excedente_visualizacion`    | `DECIMAL(10, 2)` | Excedente de la puja ganadora para frontend.              |

<br>

#### 8. Puja (`puja`)

| Atributo                 | Tipo de Dato     | Observaciones Clave                                                         |
| :----------------------- | :--------------- | :-------------------------------------------------------------------------- |
| **`id`**                 | `INTEGER`        | Clave primaria.                                                             |
| `id_lote`                | `INTEGER`        | Lote subastado.                                                             |
| `id_usuario`             | `INTEGER`        | Usuario que realiza la puja.                                                |
| `monto_puja`             | `DECIMAL(15, 2)` | Monto ofertado.                                                             |
| **`estado_puja`**        | `ENUM`           | Estados detallados: `"activa"`, `"ganadora_pendiente"`, `"perdedora"`, etc. |
| `fecha_vencimiento_pago` | `DATE`           | Fecha l√≠mite para que el ganador pague.                                     |
| `id_suscripcion`         | `INTEGER`        | Suscripci√≥n asociada a la puja.                                             |

---

### Otros Modelos de Apoyo

#### 9. Inversion (`inversion`)

| Atributo                         | Tipo de Dato     | Observaciones Clave                                                |
| :------------------------------- | :--------------- | :----------------------------------------------------------------- |
| **`id`**                         | `INTEGER`        | Clave primaria.                                                    |
| `monto`                          | `DECIMAL(15, 2)` | Dinero invertido.                                                  |
| `id_usuario` / **`id_inversor`** | `INTEGER`        | Usuario que invierte (Nota: FK en asociaciones es `id_inversor`).  |
| `id_proyecto`                    | `INTEGER`        | Proyecto invertido.                                                |
| **`estado`**                     | `ENUM`           | Opciones: `"pendiente"`, `"pagado"`, `"fallido"`, `"reembolsado"`. |
| `fecha_inversion`                | `DATE`           |                                                                    |

<br>

#### 10. Contrato (`contrato`)

| Atributo                | Tipo de Dato | Observaciones Clave                             |
| :---------------------- | :----------- | :---------------------------------------------- |
| **`id`**                | `INTEGER`    | Clave primaria.                                 |
| `id_proyecto`           | `INTEGER`    | Proyecto al que pertenece.                      |
| `id_usuario_firmante`   | `INTEGER`    | Usuario que ha firmado (puede ser nulo).        |
| `nombre_archivo`        | `STRING`     | Nombre del archivo PDF.                         |
| `hash_archivo_original` | `STRING(64)` | **Hash SHA-256 para integridad** del documento. |

<br>

#### 11. CuotaMensual (`cuota_mensual`)

| Atributo                  | Tipo de Dato     | Observaciones Clave                      |
| :------------------------ | :--------------- | :--------------------------------------- |
| **`id`**                  | `INTEGER`        | Clave primaria.                          |
| `id_proyecto`             | `INTEGER`        | Proyecto de suscripci√≥n.                 |
| **`valor_mensual_final`** | `DECIMAL(18, 2)` | Monto final que paga el usuario por mes. |
| `total_cuotas_proyecto`   | `INTEGER`        | Duraci√≥n total de las cuotas.            |

<br>

#### 12. ResumenCuenta (`resumenes_cuentas`)

| Atributo                            | Tipo de Dato | Observaciones Clave                        |
| :---------------------------------- | :----------- | :----------------------------------------- |
| **`id`**                            | `INTEGER`    | Clave primaria.                            |
| **`id_suscripcion`**                | `INTEGER`    | Suscripci√≥n a la que pertenece el resumen. |
| `cuotas_pagadas`, `cuotas_vencidas` | `INTEGER`    | Contadores de cuotas.                      |
| `porcentaje_pagado`                 | `FLOAT`      | Porcentaje de avance de la suscripci√≥n.    |
| `detalle_cuota`                     | `JSONB`      | Detalles completos de la cuota mensual.    |

<br>

#### 13. Mensaje (`mensaje`)

| Atributo       | Tipo de Dato | Observaciones Clave                |
| :------------- | :----------- | :--------------------------------- |
| **`id`**       | `INTEGER`    | Clave primaria.                    |
| `id_remitente` | `INTEGER`    | ID del usuario que env√≠a.          |
| `id_receptor`  | `INTEGER`    | ID del usuario que recibe.         |
| `contenido`    | `TEXT`       | Contenido del mensaje.             |
| `leido`        | `BOOLEAN`    | Indica si el receptor lo ha le√≠do. |

<br>

#### 14. Imagen (`imagen`)

| Atributo      | Tipo de Dato  | Observaciones Clave                 |
| :------------ | :------------ | :---------------------------------- |
| **`id`**      | `INTEGER`     | Clave primaria.                     |
| `url`         | `STRING(255)` | URL de la imagen.                   |
| `id_proyecto` | `INTEGER`     | Proyecto asociado (puede ser nulo). |
| `id_lote`     | `INTEGER`     | Lote asociado (puede ser nulo).     |

<br>

#### 15. SuscripcionCancelada (`suscripcion_cancelada`)

| Atributo                      | Tipo de Dato     | Observaciones Clave                      |
| :---------------------------- | :--------------- | :--------------------------------------- |
| **`id`**                      | `INTEGER`        | Clave primaria.                          |
| **`id_suscripcion_original`** | `INTEGER`        | FK de la suscripci√≥n que fue cancelada.  |
| `id_usuario`, `id_proyecto`   | `INTEGER`        |                                          |
| `meses_pagados`               | `INTEGER`        | Meses pagados hasta la cancelaci√≥n.      |
| `monto_pagado_total`          | `DECIMAL(15, 2)` | Monto total pagado hasta la cancelaci√≥n. |
| `fecha_cancelacion`           | `DATE`           |                                          |

---

# ‚ö†Ô∏è PASO 4: Reglas de Negocio CR√çTICAS

¬øQu√© son las Reglas de Negocio?
Las reglas de negocio son las restricciones, validaciones y procesos que el backend implementa para mantener la integridad y coherencia de los datos. Si no las respetas en el frontend, tus requests fallar√°n.
¬øPor qu√© es cr√≠tico conocerlas?

‚úÖ Evitar√°s errores 400, 409 y 500
‚úÖ Entender√°s por qu√© ciertas acciones requieren verificaciones previas
‚úÖ Sabr√°s qu√© datos validar antes de enviarlos al backend
‚úÖ Implementar√°s la UI correctamente

üîê Servicios de Seguridad (Auth Utilities)
authService.js (Backend)
El servicio de seguridad de autenticaci√≥n es fundamental para el manejo seguro de contrase√±as. Su funci√≥n principal es gestionar el hashing antes del almacenamiento y la comparaci√≥n segura durante el inicio de sesi√≥n.
Librer√≠a: bcryptjs (est√°ndar de la industria)
Regla cr√≠tica: üö´ NUNCA almacenar contrase√±as en texto plano

M√©todos Principales
M√©todoProp√≥sitoRegla de NegociohashPasswordConvierte la contrase√±a de texto plano en un hash seguroSEGURIDAD: La contrase√±a almacenada en Usuario.contrase√±a_hash siempre debe ser el resultado de este procesocomparePasswordComprueba si una contrase√±a ingresada coincide con el hash almacenadoLOGIN: Utilizado durante el inicio de sesi√≥n para verificar credenciales sin desencriptar el hash

Detalles de Implementaci√≥n
hashPassword(password) - Registro
Este m√©todo se invoca durante el registro de un nuevo usuario.
Caracter√≠sticas:

Hashing: Emplea bcrypt.hash junto con un salt (valor aleatorio)
Seguridad: El factor de salt de 10 es un buen compromiso entre seguridad y rendimiento
Protecci√≥n: Garantiza que hashes distintos se generen incluso para contrase√±as id√©nticas, previniendo ataques de tablas rainbow

Ejemplo de uso:
javascriptconst nuevoUsuario = {
password: "miPasswordSecreta", // Texto plano
};

// 1. Hashear
const hashedPassword = await authService.hashPassword(nuevoUsuario.password);

// 2. Guardar en la DB
// Usuario.create({ ..., contrase√±a_hash: hashedPassword });

comparePassword(password, hash) - Login
Este m√©todo se invoca durante el inicio de sesi√≥n.
Caracter√≠sticas:

Comparaci√≥n Segura: bcrypt.compare realiza una comparaci√≥n criptogr√°fica segura
No reversible: No se puede "desencriptar" el hash para obtener la contrase√±a original

Ejemplo de uso:
javascriptconst usuarioDB = await Usuario.findOne({ where: { email } });

// Verificar la contrase√±a
const esValido = await authService.comparePassword(
contrase√±aIngresada,
usuarioDB.contrase√±a_hash
);

if (esValido) {
// ‚úÖ √âxito: Generar Token JWT
} else {
// ‚ùå Error: Credenciales inv√°lidas
}

üîê Servicio de Autenticaci√≥n de Dos Factores (2FA)
auth2faService.js (Backend)
Gestiona la Autenticaci√≥n de Dos Factores utilizando la librer√≠a speakeasy para implementar el est√°ndar TOTP (Time-based One-Time Password).
Relaci√≥n con el modelo Usuario:

is_2fa_enabled (boolean)
twofa_secret (string encriptado)

M√©todos Principales
M√©todoProp√≥sitoRegla de Negocio Cr√≠ticagenerateSecretCrea la clave secreta y la URL de aprovisionamiento (c√≥digo QR)INTEGRACI√ìN: La URL debe incluir el email del usuario para identificaci√≥n clara en la app 2FAverifyTokenVerifica si el c√≥digo de 6 d√≠gitos es v√°lidoSEGURIDAD: Usa window: 1 para permitir ¬±30 segundos de desfaseenable2FAMarca al usuario como is_2fa_enabled: trueVALIDACI√ìN: Solo llamar despu√©s de validar el token de prueba inicialdisable2FADeshabilita el 2FADOBLE VERIFICACI√ìN: Requiere contrase√±a actual + c√≥digo TOTP actual

Flujo Cr√≠tico: Activaci√≥n de 2FA
La implementaci√≥n del 2FA impone reglas estrictas sobre el flujo de seguridad.
Proceso de Activaci√≥n (2 Pasos)
PasoM√©todoAcci√≥nPaso A: Generaci√≥ngenerateSecret(email)El sistema genera el c√≥digo QR y guarda el secreto temporalmentePaso B: Confirmaci√≥nverifyToken(secret, token)El usuario ingresa un c√≥digo de prueba. Si es v√°lido, se llama a enable2FA para hacerlo permanente
‚ö†Ô∏è Importante: El secreto NO debe guardarse en la DB hasta confirmar que el usuario configur√≥ correctamente la app.

Flujo Cr√≠tico: Desactivaci√≥n de 2FA
El m√©todo disable2FA combina verificaciones de otros servicios para garantizar m√°xima seguridad:
javascript/_ L√≥gica clave en disable2FA _/

// 1. Verificar Contrase√±a (Usa authService)
const passwordMatch = await authService.comparePassword(
currentPassword,
user.contrase√±a_hash
);

// 2. Verificar C√≥digo TOTP (Usa verifyToken del propio servicio)
const isTotpValid = auth2faService.verifyToken(user.twofa_secret, totpCode);

// 3. Desactivar si ambos son correctos
if (passwordMatch && isTotpValid) {
await user.update({
is_2fa_enabled: false,
twofa_secret: null // Eliminar la clave secreta
});
}
Reglas:

‚úÖ Verificaci√≥n de contrase√±a ‚Üí Confirma identidad del usuario
‚úÖ Verificaci√≥n de c√≥digo 2FA ‚Üí Confirma acceso al dispositivo
‚úÖ Eliminaci√≥n del secreto ‚Üí Previene reutilizaci√≥n

üìÑ Servicio de Gesti√≥n e Integridad de Contratos
contratoService.js (Backend)
Administra los registros del modelo Contrato. Su funci√≥n m√°s cr√≠tica es garantizar criptogr√°ficamente que los documentos legales no han sido manipulados.
Dependencia: Utiliza generateFileHash para verificar integridad.

M√©todos Principales
M√©todoProp√≥sitoL√≥gica de Negocio Cr√≠ticacreate(data)Registra un nuevo contratoRequiere hash_archivo_original en data al momento de la creaci√≥nfindAndVerifyById(id)M√âTODO CENTRAL: Obtiene el contrato y verifica su integridadCompara hash_archivo_original (DB) con hash actual del archivo f√≠sicofindById(id)Wrapper de findAndVerifyByIdAsegura que la verificaci√≥n se ejecute siempre por defectocreateSignedContractRegistra el contrato generado y firmado individualmenteEspera URL, Hash y id_usuario_firmante √∫nicosregisterSignatureActualiza un contrato base con datos de firma electr√≥nicaVincula id_inversion_asociada y hash de firma al contrato basesoftDelete(id)Desactiva un contrato (borrado suave)Usa activo: false para mantener historial legal

Regla Cr√≠tica: Integridad Criptogr√°fica (Hash Check)
La l√≥gica m√°s importante reside en findAndVerifyById.
üîë Concepto de Integridad
El campo Contrato.hash_archivo_original almacena el valor de hash del archivo PDF cuando fue cargado por primera vez.
Si el archivo f√≠sico cambia de alguna manera, generateFileHash devolver√° un valor diferente.

üö® Mecanismo de Verificaci√≥n
javascript// L√≥gica clave dentro de findAndVerifyById
const hashActual = await generateFileHash(contrato.url_archivo);

if (hashActual !== contrato.hash_archivo_original) {
// ‚ö†Ô∏è ¬°El archivo f√≠sico no coincide con el registro original!
contrato.dataValues.integrity_compromised = true;
console.warn('üö® INTEGRIDAD COMPROMETIDA:', contrato.id);
} else {
contrato.dataValues.integrity_compromised = false;
}

return contrato;
Pasos:

Obtener el registro del contrato de la DB (incluye hash_archivo_original)
Calcular hash actual del archivo f√≠sico con generateFileHash(url_archivo)
Comparar:

‚úÖ Iguales ‚Üí integrity_compromised: false
‚ùå Diferentes ‚Üí integrity_compromised: true + console.warn de seguridad

Flujo de Firma de Contratos
El m√©todo registerSignature es clave para finalizar una inversi√≥n:
javascript/_ Ejemplo de Uso de registerSignature _/
const firmaExitosa = {
url_documento_firmado: '...',
hash_documento_firmado: '...',
id_inversion_asociada: 45,
fecha_firma: new Date(),
};

await contratoService.registerSignature(idContratoBase, firmaExitosa);
Proceso:

Usuario realiza una inversi√≥n
Se genera un documento PDF √∫nico para la inversi√≥n
registerSignature vincula este documento firmado y su hash de integridad con el contrato base del proyecto
La inversi√≥n queda legalmente respaldada

üí∞ Servicio de C√°lculo de Cuotas Mensuales
cuotaMensualService.js (Backend)
Administra el modelo CuotaMensual. Su prop√≥sito principal es calcular el monto exacto que los usuarios deben pagar mensualmente por una suscripci√≥n.
Aplica directamente la Regla: Los proyectos de tipo mensual DEBEN tener una configuraci√≥n de cuota.

M√©todos Principales
M√©todoProp√≥sitoL√≥gica de Negocio Clave_calculateValuesFUNCI√ìN CENTRAL: Realiza todos los c√°lculos financierosDefine valor_mensual_final sumando plan + administraci√≥n + IVA. Redondea a 2 decimalescreateAndSetProjectAmountCrea la cuota y la vincula al proyectoTRANSACCI√ìN CR√çTICA: Usa transacci√≥n de Sequelize para crear Cuota Y actualizar monto_inversion del Proyecto at√≥micamenteupdateRecalcula y actualiza una cuota existenteMantiene coherencia financiera al recalcular y actualizar montos del ProyectofindByProjectIdObtiene historial de cuotas de un proyecto√ötil para seguimiento administrativo

L√≥gica de C√°lculo Financiero
üßÆ F√≥rmula Completa
javascript// 1. Costo Base (valor_movil)
valor_movil = valor_cemento_unidades √ó valor_cemento

// 2. Total del Plan
total_del_plan = valor_movil √ó (porcentaje_plan / 100)

// 3. Valor Mensual (Sin Cargos)
valor_mensual = total_del_plan / total_cuotas_proyecto

// 4. Carga Administrativa
carga_administrativa = valor_movil √ó (porcentaje_administrativo / 100)

// 5. IVA sobre Administraci√≥n
iva_carga_administrativa = carga_administrativa √ó (porcentaje_iva / 100)

// 6. Valor Mensual FINAL
valor_mensual_final = valor_mensual + carga_administrativa + iva_carga_administrativa
‚ö†Ô∏è Nota Cr√≠tica: Todos los valores se redondean a 2 decimales (toFixed(2)) para garantizar precisi√≥n financiera.

Transacciones At√≥micas
ObjetoProp√≥sitoImpacto si FallaCuotaMensualCreaci√≥n/Actualizaci√≥n del registro de cuotaSi falla, el proyecto nunca se actualizaProyectoActualizaci√≥n de monto_inversion con valor_mensual_finalSi falla, la creaci√≥n de cuota se revierte (rollback)
El flujo asegura: Ambas operaciones se completan con √©xito, o ninguna lo hace.
Esto previene que un proyecto de suscripci√≥n tenga una cuota en la DB pero muestre un monto de inversi√≥n incorrecto.

üìß Servicio de Correo Electr√≥nico (Notificaciones)
emailService.js (Backend)
Gestiona el env√≠o de correos electr√≥nicos transaccionales utilizando nodemailer.

Configuraci√≥n Base
ComponenteConfiguraci√≥nConsideraciones de SeguridadTransportadornodemailer.createTransportUtiliza variables de entorno (EMAIL_USER, EMAIL_PASS)Proveedorservice: "gmail"En producci√≥n, migrar a SendGrid, Mailgun o AWS SESFunci√≥n BasesendEmail(to, subject, text, html)Es la √∫nica que interact√∫a con el transportador

Flujos de Comunicaci√≥n Cr√≠ticos

1. Confirmaci√≥n de Cuenta üîí
   M√©todo: sendConfirmationEmail
   Prop√≥sito: Activar la cuenta del usuario reci√©n registrado, asegurando la validez del correo.
   Regla CR√çTICA: La URL de confirmaci√≥n en el correo debe apuntar a un endpoint del backend que valide el token y cambie el estado del usuario (is_active: true) antes de redirigirlo al frontend.
   javascript/_ Endpoint de ejemplo _/
   // Despu√©s de crear el nuevo usuario:
   const token = generateConfirmationToken(newUser.id);
   await emailService.sendConfirmationEmail(newUser, token);

2. Notificaci√≥n de Ganador de Lote üèÜ
   M√©todo: notificarGanadorPuja
   Prop√≥sito: Informar al usuario que ha ganado una puja y establecer fecha l√≠mite de pago.
   Flujo:

Se activa por el servicio de pujas/lotes al finalizar una subasta
Se maneja la l√≥gica de Reasignaci√≥n (esReasignacion)
Se establece el plazo fijo de 90 d√≠as para completar el pago

javascriptconst limite = new Date(Date.now() + 90 _ 24 _ 60 _ 60 _ 1000).toLocaleDateString();

await emailService.notificarGanadorPuja(
ganador,
lote.id,
limite,
true // esReasignacion
);

3. Notificaci√≥n de Impago üõë
   M√©todo: notificarImpago
   Prop√≥sito: Informar al usuario que ha perdido un lote por no cumplir con el plazo de 90 d√≠as.
   Regla CR√çTICA: El correo debe confirmar expl√≠citamente que el token de subasta ha sido devuelto a la cuenta del usuario.

üñºÔ∏è Servicio de Gesti√≥n de Im√°genes
imagenService.js (Backend)
Administra el modelo Imagen para controlar el contenido visual asociado a Proyectos y Lotes.
Concepto clave: Borrado suave (soft delete) para mantener historial de activos visuales.

M√©todos Principales
M√©todoProp√≥sitoL√≥gica de Negocio Clavecreate(data)Registra la URL y metadatos de una nueva imagenAsume que el archivo ya fue subido a S3/GCS/etc.softDelete(id)Borrado L√≥gico: Desactiva la imagen (activo: false)Previene eliminaci√≥n f√≠sica del archivofindByProjectIdActivoObtiene galer√≠a visual de un proyectoCR√çTICO: Usa activo: true para mostrar solo im√°genes disponiblesfindByLoteIdActivoObtiene im√°genes espec√≠ficas de un loteFiltra por activo: truefindAllActivoConsulta general de im√°genes visiblesEst√°ndar de la plataforma para listas p√∫blicas

L√≥gica de Borrado Suave
javascript// Borrado suave
async softDelete(id) {
const imagen = await Imagen.findByPk(id);
if (!imagen) return null;

imagen.activo = false; // Solo cambia el estado
return await imagen.save();
}

// Consulta activa
async findByProjectIdActivo(id_proyecto) {
return await Imagen.findAll({
where: {
id_proyecto: id_proyecto,
activo: true, // FILTRO CR√çTICO DE NEGOCIO
},
});
}
Beneficios:

‚úÖ Seguridad y auditor√≠a
‚úÖ Mantiene historial de URLs de contenido subido
‚úÖ Evita que URLs eliminadas accidentalmente reaparezcan
‚úÖ Administradores pueden ver historial completo

üíº Servicio de Gesti√≥n de Inversiones
inversionService.js (Backend)
Maneja la creaci√≥n y confirmaci√≥n de inversiones de usuarios en proyectos.
Clave: Transaccionalidad y aplicaci√≥n de reglas para garantizar que los proyectos no acepten inversiones cuando no deben.

M√©todos Principales
M√©todoProp√≥sitoL√≥gica de Negocio ClavecrearInversionRegistra la intenci√≥n de inversi√≥nValidaci√≥n Previa: Chequea que el proyecto no est√© Finalizado/Cancelado, sea tipo directo y tenga monto_inversion definidoconfirmarInversionProcesa el pago exitoso de una inversi√≥nTRANSACCI√ìN CR√çTICA: Actualiza estado a pagado, incrementa suscripciones_actuales, finaliza Proyecto si es tipo directofindByUserIdObtiene historial de inversiones de un usuarioEsencial para "Mis Inversiones" en el frontendsoftDeleteDesactiva una inversi√≥n (borrado suave)Mantiene historial de transacciones

Flujo de Creaci√≥n de Inversi√≥n
Paso 1: crearInversion (Solo registra intenci√≥n)
javascriptconst nuevaInversion = await Inversion.create({
monto: proyecto.monto_inversion,
estado: "pendiente", // CR√çTICO: Esperando webhook de pago
// ...
});
Validaciones:

‚úÖ Estado: Impide inversi√≥n en proyectos Finalizados o Cancelados
‚úÖ Tipo: Asegura que solo proyectos tipo_inversion: 'directo' usen este endpoint
‚úÖ Transacci√≥n: Usa transacci√≥n de DB para atomicidad

Flujo de Confirmaci√≥n de Pago
Paso 2: confirmarInversion (Llamado desde webhook de pagos)
Exige una transacci√≥n de Sequelize (t) ya iniciada.
javascript// Bloqueo de registros
const inversion = await Inversion.findByPk(id, {
transaction: t,
lock: t.LOCK.UPDATE
});

// Incremento de fondeo
proyecto.suscripciones_actuales += inversion.monto;

// Actualizaci√≥n de estados
inversion.estado = "pagado";

if (proyecto.tipo_inversion === "directo") {
proyecto.estado_proyecto = "Finalizado";
}
Si alguna operaci√≥n falla: Rollback autom√°tico mantiene coherencia de datos.

üîë Servicio de JSON Web Token (JWT)
jwtService.js (Backend)
Se encarga de la creaci√≥n, firma y verificaci√≥n de JSON Web Tokens para manejar sesiones de usuario y flujos de seguridad cr√≠ticos (como 2FA).
Librer√≠a: jsonwebtoken
Clave secreta: process.env.JWT_SECRET

M√©todos Principales
M√©todoProp√≥sitoDuraci√≥n (expiresIn)L√≥gica de Negocio ClavegenerateTokenCrea el token de sesi√≥n principal (en login exitoso)1 horaContiene id, nombre_usuario y rol. Se usa para autorizaci√≥n en cada solicitudverifyTokenVerifica y decodifica el token de sesi√≥n-Utilizado por middleware de autenticaci√≥n para proteger rutasgenerate2FATokenCrea un token temporal para proceso de verificaci√≥n 2FA5 minutosSolo contiene id. Su corta duraci√≥n mitiga riesgo de roboverify2FATokenVerifica el token de 2FA-Usado para finalizar login despu√©s del c√≥digo TOTP

Reglas de Seguridad Clave

1. Separaci√≥n de Prop√≥sito y Duraci√≥n (TTL)
   Tipo de TokenTTLUsoSesi√≥n (generateToken)1 horaActividad diaria del usuario (consultar proyectos, inversiones, etc.)Proceso (generate2FAToken)5 minutosValidar pasos sensibles (2FA, recuperaci√≥n contrase√±a). No reusable

2. Informaci√≥n del Payload
   Sesi√≥n Normal:
   javascriptconst payload = {
   id: 42,
   nombre_usuario: "admin_pablo",
   rol: "administrador",
   iat: 1634283600, // Emitido en...
   exp: 1634287200, // Expira en...
   };
   2FA:
   javascriptconst payload = {
   id: 42, // Solo ID
   };
   ‚ö†Ô∏è Consideraci√≥n CR√çTICA: La variable JWT_SECRET debe ser larga, compleja y √∫nica para producci√≥n. Si se compromete, todos los tokens quedan vulnerables.

üèÜ Servicio de Lotes y Subastas
loteService.js (Backend)
Administra el modelo Lote, que representa los activos que se subastan. Contiene la l√≥gica de negocio m√°s cr√≠tica y compleja de la plataforma.

M√©todos Principales
M√©todoProp√≥sitoL√≥gica de Negocio ClaveupdateActualiza un loteNotificaci√≥n: Si estado cambia de inactivo a activa, env√≠a mensajes a todos los usuarios activosendAuctionFinaliza una subasta activaTRANSACCI√ìN CR√çTICA: Asigna ganador potencial, marca puja ganadora, establece plazo de 90 d√≠as, libera tokensasignarSiguientePujaReasigna el lote al siguiente postor v√°lidoNotificaci√≥n de Reasignaci√≥n: Usa emailService con flag esReasignacion: trueprocesarImpagoLoteManeja el vencimiento del plazo de pagoCRON JOB: Marca puja como ganadora_incumplimiento, devuelve token, notifica, inicia reasignaci√≥nprepararLoteParaReingresoLimpia un lote para ser reutilizadoDespu√©s de 3 intentos fallidos. Libera √∫ltimo token, elimina pujas, reinicia estado a pendiente

Flujo de Subasta, Pago y Reasignaci√≥n

1. Finalizaci√≥n de Subasta (endAuction)
   javascriptconst t = await sequelize.transaction();

try {
// Identificaci√≥n de ganador
const pujaGanadora = await encontrarPujaMasAlta();

// Actualizaci√≥n de estados
lote.estado_subasta = "finalizada";
lote.id_ganador = pujaGanadora.id_usuario;
lote.intentos_fallidos_pago = 1; // Primer intento

puja.estado_puja = "ganadora_pendiente";
puja.fecha_vencimiento_pago = new Date(Date.now() + 90 _ 24 _ 60 _ 60 _ 1000);

await t.commit();

// Post-Commit: Notificar ganador y liberar tokens de perdedores
} catch (error) {
await t.rollback();
}

2. Gesti√≥n de Impago (Cron Job ‚Üí procesarImpagoLote)
   Esta es la l√≥gica de negocio m√°s delicada.
   javascript// Identificaci√≥n de incumplidor
   const pujaIncumplidora = await encontrarPujaVencida();

// Acciones sobre incumplidor
puja.estado_puja = "ganadora_incumplimiento";

// CR√çTICO: Devolver token
await PujaService.devolverTokenPorImpago(puja);

// Notificar
await emailService.notificarImpago(usuario);

// Contador de intentos
lote.intentos_fallidos_pago++;

if (lote.intentos_fallidos_pago <= 3) {
// Reasignar al siguiente postor
await asignarSiguientePuja(lote.id);
} else {
// Limpiar lote para pr√≥ximo ciclo
await prepararLoteParaReingreso(lote.id);
}

13.1 mensajeService.js (Backend)
M√©todo Prop√≥sito Principal L√≥gica de Negocio Clave
enviarMensajeSistema FUNCI√ìN CLAVE. Crea un mensaje autom√°tico con el remitente fijo SYSTEM_USER_ID (ID 1). NOTIFICACIONES: Usado por otros servicios (como loteService) para enviar avisos cr√≠ticos (ganadores de pujas, impagos, activaciones, etc.).
obtenerPorUsuario Obtiene la bandeja de entrada y salida completa de un usuario. Utiliza el operador [Op.or] para buscar mensajes donde el usuario sea remitente O receptor, permitiendo la vista unificada del buz√≥n.
obtenerConversacion Filtra mensajes entre dos usuarios espec√≠ficos. √ötil para la funcionalidad de chat o soporte directo entre usuarios.
contarNoLeidos Devuelve el n√∫mero de mensajes pendientes de lectura. Esencial para la funcionalidad del indicador de notificaciones en la interfaz de usuario.
marcarComoLeido Actualiza el estado del mensaje. SEGURIDAD: Solo permite que el usuario que es el receptor del mensaje cambie su estado a leido: true.

Exportar a Hojas de c√°lculo
13.2 Regla de Negocio Cr√≠tica: Usuario del Sistema
La variable SYSTEM_USER_ID = 1 establece una regla de negocio estricta para la mensajer√≠a:

Identidad: El usuario con el ID 1 se reserva exclusivamente para la Administraci√≥n y Notificaciones Autom√°ticas del Sistema.

Prop√≥sito de enviarMensajeSistema: Esta funci√≥n garantiza que las notificaciones transaccionales o cr√≠ticas enviadas por la aplicaci√≥n (como la activaci√≥n de una subasta o la p√©rdida de un lote) tengan una fuente clara y consistente.

JavaScript

/_ Uso en otro servicio, por ejemplo, al notificar al ganador de una puja _/
await mensajeService.enviarMensajeSistema(
ganador.id,
"¬°Felicidades! Has ganado el Lote #10."
);
// En la DB, el id_remitente ser√° '1' (Sistema).
13.3 Consistencia de la Bandeja de Entrada
El m√©todo obtenerPorUsuario es la puerta de entrada a la mensajer√≠a, asegurando que el usuario vea todos los mensajes relevantes:

Al usar [Op.or] en la consulta, se combinan todos los mensajes donde:

El id_remitente es el usuario actual (mensajes enviados).

El id_receptor es el usuario actual (mensajes recibidos).

Las cl√°usulas include: [ {model: Usuario, as: "remitente"}, ... ] son necesarias para mostrar en el frontend el nombre de la persona que env√≠a o recibe el mensaje, en lugar de solo su ID.

Servicio de Gesti√≥n de Pagos

El servicio pagoService.js administra el modelo Pago y es el responsable de la l√≥gica de facturaci√≥n mensual para los proyectos de tipo suscripci√≥n. Combina el cobro recurrente con la compleja aplicaci√≥n de saldos a favor generados en el sistema de Pujas.

14.1 pagoService.js (Backend)
M√©todo Prop√≥sito Principal L√≥gica de Negocio Clave
generarPagoMensualConDescuento Crea la cuota del mes, aplicando saldo a favor del usuario. Transacci√≥n para decrementar el saldo a favor en la Suscripcion y crear el Pago. Si el saldo cubre la cuota, el estado_pago se marca como cubierto_por_puja.
markAsPaid Finaliza el proceso de pago exitoso. Transacci√≥n para marcar el pago como pagado, establecer fecha_pago y enviar notificaciones (email y mensaje interno).
handlePaymentFailure Maneja una transacci√≥n de pago fallida (ej. webhook de pasarela). CR√çTICO: Si es el Pago del Mes 1, lo marca como cancelado para prevenir la generaci√≥n de cuotas futuras. Si es un mes posterior, mantiene el estado pendiente/vencido.
getValidPaymentDetails Recupera y valida un pago para ser procesado por el controlador de pago. Verifica que el usuario autenticado sea el propietario del pago a trav√©s de la Suscripcion asociada y que el estado sea pendiente o vencido.
findPaymentsDueSoon / findOverduePayments Consulta pagos pr√≥ximos a vencer o vencidos. Destinados a ser utilizados por un Scheduler (Cron Job) para enviar recordatorios y notificaciones de morosidad.

Exportar a Hojas de c√°lculo
14.2 Flujo de Generaci√≥n de Pagos y Descuentos (generarPagoMensualConDescuento)
Esta funci√≥n es clave para la automatizaci√≥n de cobros mensuales y la integraci√≥n del sistema de recompensas (saldos a favor):

Transacci√≥n y Obtenci√≥n de Datos: Se abre una transacci√≥n para buscar la SuscripcionProyecto y el Proyecto asociado.

Determinaci√≥n del Pr√≥ximo Mes: Se busca el √∫ltimo pago para determinar el proximoMes (Mes 1, 2, 3, etc.).

L√≥gica de Descuento (Saldo a Favor):

Se obtiene el saldoAFavor actual de la suscripci√≥n.

Si saldoAFavor > 0, se calcula el montoAPagar = Math.max(0, cuotaMensual - saldoAFavor).

Se actualiza el campo suscripcion.saldo_a_favor con el remanente.

Estado del Pago:

Si montoAPagar > 0: estado_pago es "pendiente".

Si montoAPagar === 0: estado_pago es "cubierto_por_puja". Esto cierra el pago inmediatamente sin requerir una transacci√≥n de pasarela.

Creaci√≥n y Decremento: Se crea el nuevo registro de Pago con el monto final y se decrementa suscripcion.meses_a_pagar.

Plazo de Vencimiento Fijo
La fecha de vencimiento (fecha_vencimiento) se establece de forma fija al d√≠a 10 del mes en curso, facilitando la gesti√≥n de la morosidad.

14.3 Gesti√≥n de la Morosidad (Cron Jobs)
Los m√©todos findPaymentsDueSoon y findOverduePayments son la base para un sistema de recordatorios automatizados:

M√©todo Filtro L√≥gico Prop√≥sito
findPaymentsDueSoon Pagos pendiente con fecha_vencimiento entre Hoy y Hoy + 3 d√≠as. Enviar Alertas de recordatorio (ej., "Tu pago vence en 3 d√≠as").
findOverduePayments Pagos pendiente con fecha_vencimiento anterior a Hoy ([Op.lt]). Enviar Avisos de morosidad y eventualmente aplicar la l√≥gica de suspensi√≥n de la suscripci√≥n.

Exportar a Hojas de c√°lculo
El m√©todo updateLastNotificationDate es necesario para evitar enviar m√∫ltiples recordatorios en un corto per√≠odo de tiempo a un mismo usuario para el mismo pago pendiente.

Servicio de Pagos (Mercado Pago Integration)

El servicio paymentService.js es la capa de abstracci√≥n entre la l√≥gica de negocio de la plataforma y el SDK de Mercado Pago. Su principal responsabilidad es la gesti√≥n transaccional de los pagos, asegurando que el estado de la Transaccion interna y los pagos externos sean consistentes.

15.1 paymentService.js (Backend)
M√©todo Prop√≥sito Principal Integraci√≥n Externa L√≥gica de Negocio Clave
createPaymentSession Genera la URL de pago de Mercado Pago. Preference Env√≠a la transaccionId local como external_reference y configura la notification_url (webhook) para la comunicaci√≥n as√≠ncrona.
verifyAndFetchPayment Extrae y verifica los detalles de un pago desde un webhook. Payment Filtra por el topic payment y utiliza el paymentId para consultar los detalles a Mercado Pago.
procesarPagosDeMerchantOrder Maneja los pagos agrupados por una Orden de Comercio (MO). MerchantOrder CR√çTICO/TRANSACCIONAL: Procesa cada pago dentro de la MO. Llama a transaccionService.confirmarTransaccion o procesarFalloTransaccion dentro de una transacci√≥n de DB para garantizar la atomicidad.
refreshPaymentStatus Consulta el estado de una transacci√≥n de forma s√≠ncrona (ej., desde un redirect de usuario). Payment Actualiza la tabla PagoMercado y confirma la Transaccion si el estado es pagado.

Exportar a Hojas de c√°lculo
15.2 Flujo Cr√≠tico: Webhooks y Transacciones
La funci√≥n m√°s importante es procesarPagosDeMerchantOrder, que maneja el webhook de merchant_order. Esta garantiza que las actualizaciones de estado de pago afecten correctamente a la l√≥gica de negocio local:

1. Transaccionalidad (Atomicidad)
   El m√©todo inicia una transacci√≥n de base de datos (t = await sequelize.transaction()) antes de cualquier procesamiento. Esto es fundamental porque un solo evento de Mercado Pago puede desencadenar m√∫ltiples cambios en la base de datos (actualizar Transaccion, crear PagoMercado, actualizar Inversion, etc.).

JavaScript

const t = await sequelize.transaction({ ... });

try {
// ... L√≥gica de consulta a MP y procesamiento
await transaccionService.confirmarTransaccion(transaccionId, { transaction: t });
// ...
await t.commit();
} catch (error) {
await t.rollback(); // Si algo falla, se revierte todo
// ...
} 2. Mapeo de Estados
El objeto MP_STATUS_MAP es crucial para traducir los estados de la pasarela de pago (ej., approved, rejected) a estados de la plataforma local (pagado, rechazado), manteniendo una nomenclatura interna consistente.

3. Proceso de Pago
   Estado pagado (Aprobado): Si el estado final es pagado, se llama a transaccionService.confirmarTransaccion(..., { transaction: t }). Este servicio es el responsable de ejecutar la l√≥gica de negocio real (ej., crear la inversi√≥n o marcar la suscripci√≥n como activa).

Estado rechazado/devuelto: Se llama a transaccionService.procesarFalloTransaccion(..., { transaction: t }) para revertir la transacci√≥n interna (si es necesario) y notificar al usuario.

Este dise√±o separa la responsabilidad: el paymentService maneja la comunicaci√≥n con Mercado Pago, mientras que el transaccionService maneja las reglas de negocio posteriores a la confirmaci√≥n/falla del pago.

Servicio de Proyectos

¬°Perfecto! El proyectoService es crucial para definir la estructura de la inversi√≥n, estableciendo las reglas sobre c√≥mo se crear√° y fondear√° cada oportunidad.

Aqu√≠ tienes la documentaci√≥n en formato Markdown para el servicio proyectoService.js:

üèóÔ∏è PASO 16: Servicio de Proyectos
El servicio proyectoService.js gestiona el modelo Proyecto, que es el contenedor principal de una oportunidad de inversi√≥n. Su funci√≥n m√°s importante es la validaci√≥n de las reglas de negocio al momento de la creaci√≥n, asegurando la consistencia entre el tipo de inversi√≥n y sus par√°metros asociados (montos, monedas, y lotes).

16.1 proyectoService.js (Backend)
M√©todo Prop√≥sito Principal L√≥gica de Negocio Clave
crearProyecto Crea un proyecto y valida la unicidad de los lotes. Validaci√≥n Dual: 1. Reglas estrictas por tipo_inversion (directo vs. mensual). 2. CR√çTICO: Evita que los lotes sean reutilizados, buscando conflictos de idProyecto en la base de datos.
findByUserId Obtiene los proyectos en los que un usuario ha invertido. Relaci√≥n de Inversi√≥n: Utiliza include para filtrar proyectos que tienen al menos una Inversion con el id_usuario y estado: "pagado".
update Actualiza un proyecto existente. Flexibilidad: Permite la actualizaci√≥n dentro de una transacci√≥n (transaction), lo cual es esencial si la actualizaci√≥n forma parte de un flujo mayor (ej., un proceso de cambio de estado).
findAllActivo / findByIdActivo Consulta proyectos visibles para el usuario. Filtra por activo: true y siempre incluye los modelos Lote e Imagen para presentar la informaci√≥n completa.

Exportar a Hojas de c√°lculo
16.2 Reglas de Negocio en la Creaci√≥n (crearProyecto)
La l√≥gica de creaci√≥n aplica validaciones estrictas basadas en el campo tipo_inversion, definiendo si el proyecto ser√° una inversi√≥n √∫nica o un fondo de suscripci√≥n mensual:

A. Tipo directo (Inversi√≥n √önica)
Moneda: Fija a "USD".

Objetivo de Suscripciones: Fijo a 0 (irrelevante para este tipo).

Pack de Lotes: Fijo a true (Entrega anticipada activa).

Requisito: monto_inversion debe ser definido (ser√° el monto que cada inversor debe pagar).

B. Tipo mensual (Suscripci√≥n)
Moneda: Fija a "ARS".

Pack de Lotes: Fijo a false (Entrega anticipada inactiva).

Requisito: obj_suscripciones debe ser mayor a cero (define la meta de fondeo).

Requisito: monto_inversion debe ser definido (ser√° la cuota base mensual a pagar).

C. Validaci√≥n de Unicidad de Lotes
Es una regla de negocio cr√≠tica que un lote solo puede estar asociado a UN proyecto a la vez.

El servicio busca lotes que el usuario quiere asignar (lotesIds).

Utiliza Lote.findAll con where: { idProyecto: { [Op.ne]: null } } para encontrar cualquier lote de la lista que ya tenga un idProyecto asignado.

Si se encuentran lotes asignados, se lanza un error que impide la creaci√≥n del proyecto, protegiendo la integridad de la inversi√≥n.

JavaScript

// La validaci√≥n clave de unicidad de lotes
const lotesAsignados = await Lote.findAll({
where: {
id: lotesIds,
idProyecto: { [require("sequelize").Op.ne]: null },
},
});
16.3 Relaci√≥n Inversor-Proyecto (findByUserId)
Este m√©todo es esencial para la interfaz del usuario ("Mis Proyectos"). En lugar de tener una relaci√≥n directa, la propiedad se determina a trav√©s de la tabla Inversion:

Filtra los Proyectos.

Incluye la tabla Inversion con un filtro anidado (where) que exige que el id_usuario sea el consultado Y que el estado de la inversi√≥n sea "pagado" (required: true garantiza que solo se traigan los proyectos con esa inversi√≥n confirmada).

Esto asegura que solo se muestren los proyectos en los que el usuario es un inversor activo y con pago completado.

Servicio de Pujas y Subastas
El servicio pujaService.js administra el modelo Puja y el sistema de subastas por lote. Es responsable de las reglas de oferta, la gesti√≥n del token de subasta (tokens_disponibles en SuscripcionProyecto) y el crucial proceso de aplicaci√≥n de excedente (saldo_a_favor).

17.1 pujaService.js (Backend)
M√©todo Prop√≥sito Principal L√≥gica de Negocio Clave
create Crea o actualiza una puja en un lote activo. Token Consumo: Si es la primera puja del usuario en el lote, consume 1 token_disponible de la SuscripcionProyecto. Si es una actualizaci√≥n, no consume m√°s tokens. Validaci√≥n: Asegura que el monto sea mayor que la puja anterior y mayor que la puja m√°s alta.
procesarPujaGanadora CR√çTICO. Aplica el excedente de la puja ganadora despu√©s del pago. Transacci√≥n que: 1. Cubre Pagos Pendientes (estado_pago: 'pendiente'). 2. Pre-paga Meses Futuros (decrement 'meses_a_pagar'). 3. Asigna el resto a saldo_a_favor. 4. Libera el token de los perdedores (P3, etc.).
requestCheckoutForPuja Inicia el flujo de pago de la puja ganadora. Llama a getValidPaymentDetails para validar la propiedad y el estado, y luego utiliza el transaccionService para generar el checkout de la pasarela.
getValidPaymentDetails Valida que una puja est√© lista para pagarse. Asegura que el estado sea ganadora_pendiente y que el userId autenticado sea el propietario.
gestionarTokensAlFinalizar Prepara el lote para la liquidaci√≥n. Libera los tokens de todos los participantes EXCEPTO el Top 3 (P1, P2, P3), quienes quedan bloqueados hasta que se defina el ganador.
findExpiredGanadoraPendiente Busca pujas que han incumplido su plazo de pago. Utilizado por un Scheduler (Cron Job) para iniciar el proceso de morosidad/impago y reasignaci√≥n al siguiente postor.
devolverTokenPorImpago Revierte el bloqueo del token tras un impago (m√°s de 90 d√≠as). Seguridad: Incrementa solo si el tokens_disponibles es < 1, asegurando que el usuario no obtenga tokens duplicados.

Exportar a Hojas de c√°lculo
17.2 La L√≥gica del Excedente (procesarPujaGanadora)
Cuando un usuario paga exitosamente el monto de su puja ganadora, el excedente (monto_puja - precio_base) se distribuye en una estricta jerarqu√≠a de prioridades:

Prioridad 1: Cubrir Pagos Pendientes: El excedente se utiliza para cambiar el estado de cualquier Pago mensual pendiente del usuario en ese proyecto a cubierto_por_puja.

Prioridad 2: Pre-pagar Meses Futuros: Si queda excedente, se utiliza para reducir la cuenta de suscripcion.meses_a_pagar al monto de la cuota mensual (monto_inversion).

Prioridad 3: Saldo a Favor: Cualquier remanente despu√©s de cubrir los meses futuros se agrega a suscripcion.saldo_a_favor. Este saldo se aplicar√° autom√°ticamente a la pr√≥xima cuota pendiente (ver pagoService).

Prioridad 4: Excedente de Visualizaci√≥n: Si la suscripci√≥n ya est√° totalmente cubierta (meses_a_pagar <= 0), el resto se almacena en lote.excedente_visualizacion.

17.3 Gesti√≥n del Token de Subasta (Tokens)
El servicio impone una regla estricta de "Un Token por Proyecto Activo" para la participaci√≥n:

Bloqueo al Pujar (create): Al hacer la primera puja en cualquier lote de un proyecto, el tokens_disponibles de la SuscripcionProyecto pasa de 1 a 0. Esto impide que el usuario puje en otros lotes del mismo proyecto.

Liberaci√≥n de Perdedores Masivos (gestionarTokensAlFinalizar): Al final de la subasta, se devuelven los tokens a todos, excepto al Top 3 de postores.

Liberaci√≥n Final del Perdedor (procesarPujaGanadora): Cuando el ganador (P1 o P2) paga, se libera inmediatamente el token del postor que queda bloqueado (P2 o P3), dej√°ndolo disponible para otro proyecto.

Liberaci√≥n por Impago (devolverTokenPorImpago): Si un ganador incumple el pago (ej. 90 d√≠as), se le devuelve el token para que pueda participar en el futuro, pero la puja se marca como ganadora_incumplimiento.

Servicio de Resumen de Cuenta
El servicio resumenCuentaService.js gestiona el modelo ResumenCuenta, el cual act√∫a como un snapshot y un indicador de progreso para las inversiones tipo suscripci√≥n mensual. Combina los datos de la SuscripcionProyecto y los Pagos realizados para mostrar al usuario su estatus actual.

18.1 resumen_cuenta.service.js (Backend)
M√©todo Prop√≥sito Principal L√≥gica de Negocio Clave
createAccountSummary Inicializa el resumen al crear una suscripci√≥n. Atomicidad: Utiliza options (transacci√≥n) para asegurar que el resumen se cree junto con la suscripci√≥n. Snapshot: Captura el detalle de la CuotaMensual y el total_cuotas_proyecto en el momento de la suscripci√≥n para evitar inconsistencias futuras.
updateAccountSummaryOnPayment CR√çTICO. Actualiza el progreso despu√©s de un pago exitoso. C√°lculo de Progreso: Cuenta los pagos con estado pagado o cubierto_por_puja. C√°lculo de Morosidad: Estima las cuotas_vencidas restando las cuotas_pagadas de los mesesTranscurridos desde la creaci√≥n de la suscripci√≥n (moment().diff(...)).
getAccountSummariesByUserId Obtiene todos los res√∫menes del usuario. Consulta las SuscripcionProyecto del usuario y realiza un join con ResumenCuenta y Proyecto para retornar la informaci√≥n clave.
findResumenByIdAndUserId Seguridad para consultas individuales. Usa un where en la inclusi√≥n de SuscripcionProyecto (where: { id_usuario: userId }) para prevenir el acceso a res√∫menes de otros usuarios.
actualizarSaldoGeneral (Simulaci√≥n) Placeholder para saldos de inversiones directas/pujas. Funci√≥n de apoyo que indica d√≥nde se integrar√≠a la l√≥gica de saldo general del usuario si la plataforma lo requiriera (ej., para reinversi√≥n).

Exportar a Hojas de c√°lculo
18.2 L√≥gica de Actualizaci√≥n y Progreso (updateAccountSummaryOnPayment)
Esta funci√≥n es vital para reflejar el estado financiero del inversor.

1. Conteo de Pagos Pagados
   La m√©trica de cuotas_pagadas es la suma de todos los registros en la tabla Pago asociados a la suscripci√≥n que tienen un estado final y exitoso:

Pagos¬†Completados=Pagos(estado=‚Äôpagado‚Äô)‚à™Pagos(estado=‚Äôcubierto_por_puja‚Äô)
El filtro se realiza directamente al incluir el modelo Pago en la consulta a SuscripcionProyecto.

2. C√°lculo de Porcentaje
   El porcentaje_pagado se calcula utilizando la cantidad de pagos completados sobre el total de cuotas del proyecto (meses_proyecto):

Porcentaje¬†Pagado=
Total¬†Cuotas¬†Proyecto
Cuotas¬†Pagadas
‚Äã
√ó100 3. C√°lculo de Cuotas Vencidas (Morosidad)
El c√°lculo de cuotas_vencidas es una estimaci√≥n basada en el tiempo transcurrido desde que se cre√≥ la suscripci√≥n (fecha de inicio):

Meses Transcurridos: Se calcula la diferencia en meses entre la fecha actual y la fecha de creaci√≥n de la suscripci√≥n (suscripcion.createdAt) usando moment().

Cuotas Vencidas: La morosidad se define como el n√∫mero de meses que deber√≠an haber sido pagados menos el n√∫mero de cuotas que fueron pagadas:

Cuotas¬†Vencidas=max(0,Meses¬†Transcurridos‚àíCuotas¬†Pagadas)
Este c√°lculo es crucial para generar reportes y automatizar procesos de cobranza o notificaci√≥n de mora.

Servicio de Suscripci√≥n a Proyectos
El servicio suscripcionProyectoService.js administra el modelo SuscripcionProyecto, la entidad que formaliza la relaci√≥n entre un Usuario y un Proyecto de inversi√≥n de tipo mensual. Su responsabilidad principal es gestionar el estado inicial, la vinculaci√≥n a proyectos y la activaci√≥n de la l√≥gica de negocio tras el fondeo del proyecto.

19.1 suscripcionProyectoService.js (Backend)
M√©todo Prop√≥sito Principal L√≥gica de Negocio Clave
\_createSubscriptionRecord Crea el registro de suscripci√≥n y actualiza el proyecto. Transaccionalidad: Es llamado por TransaccionService y opera dentro de su transacci√≥n (t). Fondeo/Notificaci√≥n: Incrementa suscripciones_actuales del proyecto. Si se alcanza el obj_suscripciones, notifica a todos los usuarios y cambia el estado_proyecto a "En proceso". Inicializaci√≥n: Fija meses_a_pagar al plazo_inversion total del proyecto.
findByUserId Consulta todas las suscripciones activas de un usuario. Garantiza que solo se muestren las suscripciones a proyectos que tambi√©n est√°n activo: true (se asume que existe la correcci√≥n del alias proyectoAsociado).
findUsersByProjectId Obtiene la lista de usuarios (inversores) de un proyecto. Utiliza include para obtener las instancias de Usuario asociadas a las suscripciones activas.
findSubscriptionsReadyForPayments (CRON Job / Scheduler) Busca suscripciones para generar pagos. Filtra por pago_generado: false y proyectos con objetivo_cumplido: true, indicando que el proceso de generaci√≥n de cuotas debe iniciar.

Exportar a Hojas de c√°lculo
19.2 Flujo Cr√≠tico: Creaci√≥n y Fondeo (\_createSubscriptionRecord)
Esta funci√≥n se ejecuta despu√©s de que el usuario ha completado el pago inicial (la primera cuota o el monto base) a trav√©s del TransaccionService.

1. Verificaci√≥n del Proyecto
   Asegura que el proyecto est√© activo y no est√© en estado "Finalizado" o "Cancelado".

2. Configuraci√≥n Inicial del Inversor
   El campo meses_a_pagar de la suscripci√≥n se inicializa con el plazo_inversion total definido en el proyecto. Este valor se ir√° decrementando a medida que se realicen pagos o se aplique excedente de pujas.

3. Proceso de Fondeo (L√≥gica de "Crowdfunding")
   Incremento: El contador proyecto.suscripciones_actuales se incrementa en 1.

Verificaci√≥n de Objetivo: Comprueba si suscripciones_actuales ha alcanzado o superado el obj_suscripciones.

Activaci√≥n del Proyecto:

Si se cumple el objetivo y a√∫n no se ha notificado (objetivo_notificado: false), el proyecto se marca como fondeado.

Se actualiza el estado del proyecto a "En proceso".

Notificaci√≥n Masiva: Se utiliza el MensajeService para enviar una notificaci√≥n a todos los usuarios activos de la plataforma, informando que el proyecto ha sido fondeado exitosamente y ha comenzado su fase de ejecuci√≥n.

Atomicidad: Al ejecutarse dentro de la misma transacci√≥n (t) que el pago de la Transaccion, se garantiza que el usuario solo obtiene su suscripci√≥n si el proyecto se actualiza correctamente y viceversa.

19.3 Inclusi√≥n del resumenCuentaService
Aunque el m√©todo \_createSubscriptionRecord no llama directamente a resumenCuentaService.createAccountSummary, la importaci√≥n (// >>> CAMBIO CLAVE 1 <<<) indica que este es el punto l√≥gico en el flujo completo donde se debe inicializar el ResumenCuenta despu√©s de la creaci√≥n de la suscripci√≥n, garantizando que el usuario tenga un dashboard financiero desde el inicio.

Servicio de Bajas (Cancelaci√≥n de Suscripci√≥n)

El servicio suscripcionService.js se centra en la gesti√≥n del ciclo de vida de la SuscripcionProyecto, siendo su m√©todo principal el softDelete, que implementa la l√≥gica de negocio para la cancelaci√≥n de una suscripci√≥n por parte del usuario.

20.1 suscripcionService.js (Backend)
M√©todo Prop√≥sito Principal L√≥gica de Negocio Clave
softDelete CR√çTICO. Cancela una suscripci√≥n y prepara el reembolso. Transacci√≥n: Opera at√≥micamente. 1. Soft Delete: Marca activo: false en SuscripcionProyecto. 2. Contadores: Decrementa el contador suscriptores_actuales del proyecto. 3. Registro de Cancelaci√≥n: Crea un registro detallado en SuscripcionCancelada para registrar el historial de pagos y el monto total pagado, lo cual se usar√° posteriormente para el proceso de reembolso.
findById B√∫squeda simple por ID. Permite obtener la instancia de la suscripci√≥n.
findByUserIdAndProjectId B√∫squeda por par de claves (Usuario-Proyecto). √ötil para verificar si un usuario tiene una suscripci√≥n activa a un proyecto espec√≠fico.

Exportar a Hojas de c√°lculo
20.2 Flujo Cr√≠tico: Cancelaci√≥n de Suscripci√≥n (softDelete)
El m√©todo softDelete no realiza una eliminaci√≥n f√≠sica, sino que orquesta un proceso transaccional para registrar la cancelaci√≥n y sus implicaciones financieras.

Inicio Transacci√≥n: Se inicia una transacci√≥n de Sequelize (t) para asegurar la atomicidad de las operaciones.

Validaci√≥n: Verifica que la suscripci√≥n exista y que a√∫n est√© activa.

Soft Delete: La suscripci√≥n se actualiza, estableciendo activo en false.

Actualizaci√≥n del Proyecto: El campo suscriptores_actuales en el modelo Proyecto se decrementa en 1, reflejando la p√©rdida del inversor.

Registro para Reembolso (Modelo SuscripcionCancelada):

Identificaci√≥n de Pagos: Se consultan todos los registros en la tabla Pago asociados a la suscripci√≥n con el estado 'pagado'.

C√°lculo: Se suman los montos de todos los pagos exitosos para obtener el montoTotalPagado.

Creaci√≥n del Registro: Se crea una nueva entrada en el modelo SuscripcionCancelada, capturando:

id_suscripcion_original

monto_pagado_total

meses_pagados

fecha_cancelacion

Prop√≥sito: El registro de SuscripcionCancelada es la √∫nica fuente de verdad para que el equipo administrativo o un sistema de terceros pueda procesar el reembolso final al inversor de acuerdo con los t√©rminos y condiciones de la plataforma.

Cierre de Transacci√≥n: Si todas las operaciones son exitosas, se realiza el commit (await t.commit()). En caso de cualquier error, se realiza el rollback (await t.rollback()), dejando la base de datos en su estado original.

Servicio de Transacciones (Motor de Pagos)

El servicio transaccionService.js es la capa de integraci√≥n de la pasarela de pagos. Su responsabilidad principal es orquestar la creaci√≥n de la transacci√≥n, la generaci√≥n del checkout y, lo m√°s importante, la ejecuci√≥n de la l√≥gica de negocio at√≥mica al recibir una confirmaci√≥n de pago (Webhook).

21.1 transaccion.service.js (Backend)
M√©todo Prop√≥sito Principal L√≥gica de Negocio Clave
iniciarTransaccionYCheckout Punto de Entrada. Crea o reutiliza una Transaccion pendiente y genera la URL de pago. Reintento/Idempotencia: Busca transacciones pendiente o fallido para el mismo √≠tem (Inversi√≥n/Pago) y regenera el checkout (generarCheckoutParaTransaccionExistente). Puja Excepci√≥n: Para las Pujas, anula transacciones antiguas y crea una nueva para asegurar el monto actualizado.
generarCheckoutParaTransaccionExistente Flujo de Bajo Nivel. Genera la preferencia de pago en la pasarela. Garantiza que la Transaccion tenga un registro asociado en PagoMercado (findOrCreate), asegurando que el ID de la pasarela (preferenceId) est√© vinculado y que la Transaccion est√© marcada como pendiente. Requiere una transacci√≥n de BD activa.
confirmarTransaccion CR√çTICO (Webhook/√âxito). Procesa el √©xito del pago. Idempotencia: Usa Lock de Actualizaci√≥n (t.LOCK.UPDATE) para prevenir doble procesamiento. Switch de Negocio: Ejecuta el flujo espec√≠fico (manejarPagoSuscripcionInicial, manejarPagoMensual, inversionService.confirmarInversion, pujaService.procesarPujaGanadora) seg√∫n el tipo_transaccion. Cierre: Marca la Transaccion como pagado y actualiza el saldo general del usuario (resta el monto).
revertirTransaccion CR√çTICO (Reembolso/Error). Procesa la reversi√≥n de un pago exitoso. Idempotencia: Solo revierte si el estado es pagado. Switch Inverso: Ejecuta la l√≥gica de negocio opuesta a la confirmaci√≥n (ej., pagoService.markAsReverted, inversionService.revertirInversion). Cierre: Marca la Transaccion como revertido y devuelve el monto al saldo general del usuario (suma el monto).
fallarTransaccion Maneja fallos notificados por la pasarela (Webhook). Si es un Pago Mensual o Inicial, invoca pagoService.handlePaymentFailure (lo que puede desencadenar la cancelaci√≥n de la suscripci√≥n si es el Mes 1). Marca la Transaccion como fallido.

Exportar a Hojas de c√°lculo
21.2 L√≥gica de Suscripciones (Flujos de Confirmaci√≥n)
El transaccionService contiene la l√≥gica espec√≠fica para el manejo de los pagos mensuales, que son los flujos m√°s complejos.

A. Flujo pago_suscripcion_inicial (Pago 1)
Cuando se confirma el pago inicial, ocurre una cascada de operaciones cr√≠ticas:

Se invoca suscripcionService.\_createSubscriptionRecord: Se crea la entidad SuscripcionProyecto, se incrementa el contador del Proyecto y se notifica el fondeo si aplica.

Se vincula la nueva Suscripcion al Pago y a la Transaccion.

Se realiza un decrement at√≥mico en SuscripcionProyecto.meses_a_pagar (se paga el primer mes).

Se invoca pagoService.markAsPaid en el modelo Pago.

Se invoca resumenCuentaService.createAccountSummary: Se inicializa el dashboard financiero del usuario.

Se invoca resumenCuentaService.updateAccountSummaryOnPayment: Se actualiza el resumen (1 cuota pagada, 0% vencido).

B. Flujo mensual (Pagos 2+)
Cuando se confirma un pago mensual recurrente:

Se invoca pagoService.markAsPaid en el modelo Pago.

Se realiza un decrement at√≥mico en SuscripcionProyecto.meses_a_pagar.

Se invoca resumenCuentaService.updateAccountSummaryOnPayment: Se recalcula el progreso (cuotas pagadas y morosidad).

21.3 Manejo de Saldo General (Billetera)
El servicio act√∫a como el controlador del saldo general del usuario (simulado por resumenCuentaService.actualizarSaldoGeneral):

Operaci√≥n Tipo de Transacci√≥n Impacto en Saldo General
Confirmaci√≥n (√âxito de Pago) pago_suscripcion_inicial, mensual, directo, Puja Resta el monto (-montoTransaccion). El dinero se va de la cuenta del usuario.
Reversi√≥n (Reembolso) Todas (si estaban pagado) Suma el monto (montoTransaccion). El dinero regresa a la cuenta del usuario.

Exportar a Hojas de c√°lculo
Esto garantiza la doble entrada: al pagar sale dinero, al reembolsar entra dinero.

Servicio de Usuarios
El servicio usuarioService.js es el punto de control para la administraci√≥n del modelo Usuario. Maneja las funciones de creaci√≥n de cuentas, verificaci√≥n de identidad por email, restablecimiento de contrase√±as y tareas de mantenimiento del sistema (limpieza de cuentas no utilizadas).

22.1 usuario.service.js (Backend)
M√©todo Prop√≥sito Principal L√≥gica de Negocio/Seguridad Clave
create Registra un nuevo usuario en el sistema. Verificaci√≥n: Genera un confirmacion_token √∫nico y con fecha de expiracion (24 horas). Marca el usuario como confirmado_email: false. Notificaci√≥n: Env√≠a el email de confirmaci√≥n inmediatamente a trav√©s de emailService.
confirmEmail Activa la cuenta de un usuario. Validaci√≥n: Busca el token y verifica que confirmacion_token_expiracion no haya pasado ([Op.gt]: new Date()). Activaci√≥n: Si es v√°lido, actualiza confirmado_email: true y activo: true (se asume que activo es el estado principal de la cuenta).
resendConfirmationEmail Permite reenviar el correo de activaci√≥n. Genera un nuevo token de confirmaci√≥n y expira el anterior, actualizando la fecha de caducidad.
generatePasswordResetToken Inicia el flujo de recuperaci√≥n de contrase√±a. Genera un reset_password_token seguro y con una expiraci√≥n corta (1 hora).
findByResetToken Valida el token de recuperaci√≥n. Busca el token y verifica que no haya expirado, garantizando que el proceso de cambio de contrase√±a sea sensible al tiempo.
cleanUnconfirmedAccounts Mantenimiento. Elimina cuentas que nunca se activaron. Realiza un Hard Delete (eliminaci√≥n f√≠sica de la BD) de los usuarios que no han confirmado su email (confirmado_email: false) y que fueron creados hace m√°s de X d√≠as (por defecto 7 d√≠as), liberando espacio y garantizando la higiene de la base de datos.
softDelete Desactiva temporalmente un usuario. Establece activo: false para inhabilitar el acceso sin borrar el registro.
findAllActivos Obtiene solo usuarios con cuentas activas. √ötil para tareas masivas como notificaciones (visto en suscripcion_proyecto.service).

Exportar a Hojas de c√°lculo
22.2 Flujos de Seguridad y Tokens
El servicio utiliza crypto.randomBytes(20).toString("hex") para generar tokens criptogr√°ficamente seguros para dos prop√≥sitos principales:

Prop√≥sito Token Almacenado Vigencia Efecto al Fallar la Validaci√≥n
Confirmaci√≥n de Email (create, resendConfirmationEmail) confirmacion_token 24 horas El usuario no puede iniciar sesi√≥n. Si el token expira, debe solicitar un reenv√≠o.
Restablecimiento de Contrase√±a (generatePasswordResetToken) reset_password_token 1 hora El usuario no puede cambiar su contrase√±a y debe iniciar el proceso de recuperaci√≥n nuevamente.

Exportar a Hojas de c√°lculo
Nota de Implementaci√≥n: El uso de [Op.gt]: new Date() es crucial para asegurar que el token sea verificado como "a√∫n no expirado" directamente en la consulta a la base de datos.

```

```
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Controladores y rutas:

7. Mapeo de Controladores: Flujo de Autenticaci√≥n (auth.controller.js)
Esta secci√≥n detalla la funcionalidad de las funciones dentro del controlador de autenticaci√≥n, que act√∫an como la capa de orquestaci√≥n entre las peticiones HTTP y los servicios de negocio (usuarioService, authService, etc.).

7.1. Detalle del Controlador: controllers/auth.controller.js
El controlador de autenticaci√≥n maneja el flujo m√°s cr√≠tico de la API, incluyendo el manejo de contrase√±as, tokens JWT, estados de cuenta (activo, confirmado_email) y la Autenticaci√≥n de Doble Factor (2FA).

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
register	Registra un nuevo usuario en el sistema.	1. Utiliza authService.hashPassword() para cifrar la clave. 2. Llama a usuarioService.create() que persiste el usuario y genera/env√≠a el token de confirmaci√≥n por email (emailService).	201 (Created): √âxito. 400 (Bad Request): Fallo de validaci√≥n o usuario existente.
login	Inicia sesi√≥n y decide el flujo de seguridad.	1. Verifica credenciales (authService.comparePassword). 2. Bloquea si la cuenta est√° inactiva o sin confirmar (c√≥digo 403). 3. Si 2FA est√° activo: Emite un twoFaToken temporal (5m) y devuelve 202 para forzar el Paso 2. 4. Si 2FA NO est√° activo: Emite el JWT de sesi√≥n final y devuelve 200.	200 (OK): Sesi√≥n completa. 202 (Accepted): 2FA requerido. 401 (Unauthorized): Credenciales incorrectas. 403 (Forbidden): Cuenta inactiva/no confirmada.
verify2FA	Completa el proceso de login tras la verificaci√≥n 2FA.	1. Valida el twoFaToken temporal. 2. Utiliza auth2faService.verifyToken() para validar el c√≥digo TOTP de 6 d√≠gitos. 3. Si es correcto, emite el JWT de sesi√≥n final.	200 (OK): Sesi√≥n final. 401 (Unauthorized): Token o c√≥digo TOTP inv√°lido.
forgotPassword	Inicia el flujo de recuperaci√≥n de contrase√±a.	Llama a usuarioService.generatePasswordResetToken(). Env√≠a un email con el resetLink. CR√çTICO: Devuelve siempre 200 con un mensaje gen√©rico (evita enumeraci√≥n de emails).	200 (OK): Instrucciones enviadas (gen√©rico).
resetPassword	Aplica la nueva contrase√±a.	1. Verifica la validez y expiraci√≥n del :token. 2. Hashea la nueva clave. 3. Actualiza el hash de la contrase√±a y limpia los campos reset_password_token y reset_password_expires en la DB.	200 (OK): Contrase√±a actualizada. 400 (Bad Request): Token inv√°lido/expirado.
confirmarEmail	Activa la cuenta mediante el enlace.	Llama a usuarioService.confirmEmail() para cambiar confirmado_email a true.	200 (OK): Activaci√≥n exitosa. 400 (Bad Request): Token inv√°lido.
logout	Cierra la sesi√≥n (l√≥gico).	Confirma al cliente que la sesi√≥n ha terminado. CR√çTICO: El frontend es responsable de eliminar el JWT de su almacenamiento.	200 (OK).


7.2. Mapeo de Endpoints: routes/auth.routes.js
Este archivo define la estructura de la API para la autenticaci√≥n. Las rutas protegidas por authMiddleware.authenticate requieren un JWT v√°lido en el header Authorization: Bearer <token>.

M√©todo HTTP	Endpoint Completo	Middleware Requerido	Controlador Mapeado	Prop√≥sito del Endpoint
POST	/api/auth/register	Ninguno	authController.register	Registro de nuevos usuarios.
POST	/api/auth/login	Ninguno	authController.login	Paso 1 del inicio de sesi√≥n (credenciales).
POST	/api/auth/2fa/verify	Ninguno	authController.verify2FA	Paso 2 del inicio de sesi√≥n (c√≥digo TOTP).
POST	/api/auth/forgot-password	Ninguno	authController.forgotPassword	Solicitud de email para recuperaci√≥n de contrase√±a.
POST	/api/auth/reset-password/:token	Ninguno	authController.resetPassword	Aplicar la nueva contrase√±a.
POST	/api/auth/reenviar_confirmacion	Ninguno	authController.resendConfirmation	Reenv√≠a el enlace de activaci√≥n de email.
GET	/api/auth/confirmar_email/:token	Ninguno	authController.confirmarEmail	Enlace para activaci√≥n final de la cuenta.
POST	/api/auth/logout	authenticate	authController.logout	Cierre de sesi√≥n (invalida el token en el cliente).
POST	/api/auth/2fa/generate-secret	authenticate	auth2faController.generate2FASecret	Genera y devuelve el QR para la configuraci√≥n 2FA.
POST	/api/auth/2fa/enable	authenticate	auth2faController.verifyAndEnable2FA	Activa 2FA permanentemente.
POST	/api/auth/2fa/disable	authenticate	auth2faController.disable2FA	Desactiva 2FA (requiere clave y c√≥digo TOTP).

Mapeo de Controladores: Configuraci√≥n de 2FA (auth2fa.controller.js)
Este controlador maneja la l√≥gica para que un usuario pueda activar, desactivar y verificar su Autenticaci√≥n de Dos Factores (TOTP), un proceso que siempre requiere que el usuario est√© autenticado previamente (v√≠a JWT).

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
generate2FASecret	Genera la clave secreta y el QR para el setup inicial.	1. Valida que el usuario no tenga 2FA habilitado ya (is_2fa_enabled). 2. Llama a auth2faService.generateSecret() (usando el email como identificador). 3. CR√çTICO: Almacena el secreto (secret) temporalmente en la BD (campo twofa_secret) para el paso de verificaci√≥n.	200 (OK): √âxito. Devuelve otpauthUrl (URL para generar el QR) y el secret. 400 (Bad Request): 2FA ya habilitado.
verifyAndEnable2FA	Verifica el c√≥digo de prueba y activa 2FA permanentemente.	1. Valida el secret guardado previamente. 2. Utiliza auth2faService.verifyToken() para validar que el c√≥digo (token) de 6 d√≠gitos es correcto. 3. Llama a auth2faService.enable2FA() para setear is_2fa_enabled = true en la base de datos.	200 (OK): 2FA habilitado. 401 (Unauthorized): C√≥digo TOTP inv√°lido. 400 (Bad Request): Clave secreta no generada previamente.
disable2FA	Desactiva la protecci√≥n de Doble Factor.	1. Requiere la contrase√±a del usuario y el c√≥digo TOTP actual. 2. La l√≥gica de auth2faService.disable2FA() se encarga de: a) Comparar la contrase√±a. b) Verificar el c√≥digo TOTP. c) Si ambos son correctos, setea is_2fa_enabled = false y limpia el twofa_secret.	200 (OK): Deshabilitaci√≥n exitosa. 400 (Bad Request): Contrase√±a o c√≥digo TOTP incorrecto.

Este es un excelente controlador para documentar, ya que combina la gesti√≥n de archivos, la l√≥gica de negocio, la autorizaci√≥n estricta y la seguridad de integridad documental (hashing).

A continuaci√≥n, tienes la documentaci√≥n profesional de los archivos del Controlador y las Rutas de Contratos, siguiendo la estructura solicitada.

7.4. Mapeo de Controladores: Contratos y Seguridad Documental (contrato.controller.js)
Este controlador centraliza la gesti√≥n de archivos de contratos y firmas. Su l√≥gica es cr√≠tica, ya que aplica reglas estrictas de autorizaci√≥n (basadas en roles y en relaciones con las inversiones/suscripciones) y garantiza la integridad de los documentos mediante el uso de hashes criptogr√°ficos.

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
upload	Sube una plantilla de contrato base a un proyecto.	1. Seguridad de Rol: Requiere rol admin (req.user.role === 'admin'). 2. Hashing: Calcula el hash_archivo_original del archivo subido (req.file.path) mediante generateFileHash(). 3. Transacci√≥n Segura: Si el registro en contratoService.create() falla, elimina el archivo f√≠sico (fs.unlink).	201 (Created): √âxito. 403 (Forbidden): Rol incorrecto. 400 (Bad Request): Archivo faltante.
sign	Sube el contrato firmado por el usuario y registra la firma.	1. Autorizaci√≥n Reforzada: Verifica que el usuario autenticado (req.user.id) sea el due√±o de la id_inversion (estado: 'pagado') o id_suscripcion (estado: 'activa') que intenta firmar. 2. Hashing: Calcula el hash_documento_firmado del archivo firmado para verificaci√≥n futura. 3. Registro: Llama a contratoService.registerSignature() para actualizar el contrato base. CR√çTICO: Limpia el archivo f√≠sico si falla cualquier validaci√≥n o el registro en DB.	200 (OK): Firma registrada. 403 (Forbidden): No tiene autorizaci√≥n (Inversi√≥n/Suscripci√≥n no v√°lida). 400 (Bad Request): Datos faltantes. 404 (Not Found): Contrato base no existe.
findMyContracts	Obtiene todos los contratos que el usuario autenticado ha firmado o tiene acceso.	Llama a contratoService.findByUserId(userId) filtrando por relaci√≥n de usuario.	200 (OK).
findById	Obtiene los detalles de un contrato espec√≠fico.	1. Integridad: Verifica el estado integrity_compromised (asumido por el servicio). Devuelve 409 si el archivo fue alterado. 2. Autorizaci√≥n: Permite el acceso si: es Admin, es el Firmante, o tiene una Inversi√≥n/Suscripci√≥n en el proyecto. 3. Sanitizaci√≥n: Elimina datos sensibles (firma_digital, hashes) antes de enviarlos al frontend.	200 (OK). 409 (Conflict): Integridad comprometida. 403 (Forbidden): Acceso denegado. 404 (Not Found).
download	Permite la descarga segura del archivo de contrato.	1. Integridad y Autorizaci√≥n: Aplica las mismas comprobaciones que findById para bloquear descargas no autorizadas o de archivos alterados. 2. Entrega: Utiliza res.download() de Express para transmitir el archivo de forma segura.	200 (OK): Inicia la descarga. 409 (Conflict): Integridad comprometida. 403 (Forbidden): Acceso denegado. 404 (Not Found).
softDelete	Marca un contrato como inactivo.	Llama a contratoService.softDelete(id) (asumido: activo: false).	200 (OK). 404 (Not Found).

7.5. Mapeo de Endpoints: routes/contrato.routes.js
El enrutamiento de contratos requiere el uso del middleware Multer para manejar la subida de archivos, adem√°s de middleware de autenticaci√≥n y autorizaci√≥n por rol.

M√©todo HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Prop√≥sito y Notas Clave
POST	/api/contratos/upload	authenticate -> authorizeAdmin -> upload.single('contrato')	contratoController.upload	Subida de plantilla de contrato. Requiere rol Admin.
POST	/api/contratos/firmar	authenticate -> upload.single('contrato_firmado')	contratoController.sign	Subida del contrato firmado por el usuario.
GET	/api/contratos/	authenticate -> authorizeAdmin	contratoController.findAll	Lista todos los contratos (Solo Admin).
GET	/api/contratos/mis_contratos	authenticate	contratoController.findMyContracts	Lista los contratos asociados al usuario autenticado.
GET	/api/contratos/descargar/:id	authenticate	contratoController.download	Descarga segura de un contrato. (Ubicaci√≥n de la ruta CR√çTICA).
GET	/api/contratos/:id	authenticate	contratoController.findById	Obtiene detalles de un contrato espec√≠fico. (Ubicaci√≥n de la ruta CR√çTICA).
DELETE	/api/contratos/:id	authenticate -> authorizeAdmin	contratoController.softDelete	Eliminaci√≥n l√≥gica del contrato.

Mapeo de Controladores: Gesti√≥n de Cuotas Mensuales (cuota_mensual.controller.js)
Este controlador se enfoca en la creaci√≥n y consulta de las cuotas asociadas a los proyectos, siendo crucial para el seguimiento del flujo de inversi√≥n. La creaci√≥n y modificaci√≥n est√°n estrictamente restringidas a los administradores.

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
create	Registra una nueva cuota mensual en la base de datos.	1. Validaci√≥n: Verifica la existencia de id_proyecto. 2. Integraci√≥n: Llama a proyectoService.findById() para obtener datos del proyecto (nombre_proyecto, plazo_inversion). 3. Transacci√≥n Clave: Llama a cuotaMensualService.createAndSetProjectAmount() que crea la cuota y ajusta el monto total del proyecto.	201 (Created): √âxito. 400 (Bad Request): id_proyecto faltante. 404 (Not Found): Proyecto inexistente.
findByProjectId	Obtiene todas las cuotas de un proyecto espec√≠fico.	Llama a cuotaMensualService.findByProjectId(id_proyecto). No requiere validaci√≥n de rol, solo autenticaci√≥n.	200 (OK): Lista de cuotas. 500 (Internal Error).
findLastByProjectId	Obtiene la cuota m√°s reciente de un proyecto.	Llama a cuotaMensualService.findLastByProjectId(id_proyecto). √ötil para mostrar el estado actual o la siguiente cuota.	200 (OK): √öltima cuota. 404 (Not Found): Cuotas no encontradas.
update	Modifica los campos de una cuota existente.	Llama a cuotaMensualService.update(id, data).	200 (OK): Actualizaci√≥n exitosa. 404 (Not Found): Cuota inexistente.
softDelete	Elimina l√≥gicamente una cuota (cambio de estado).	Llama a cuotaMensualService.softDelete(id).	200 (OK). 404 (Not Found).


7.7. Mapeo de Endpoints: routes/cuota_mensual.routes.js
Las rutas de Cuotas Mensuales se centran en la seguridad, restringiendo las operaciones de escritura (creaci√≥n, actualizaci√≥n, eliminaci√≥n) solo a administradores. Las operaciones de lectura son accesibles para cualquier usuario autenticado.

M√©todo HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Prop√≥sito y Requisitos de Seguridad
POST	/api/cuotas/	authenticate -> authorizeAdmin	cuotaMensualController.create	Creaci√≥n de cuota. Requiere rol Admin.
GET	/api/cuotas/:id_proyecto	authenticate	cuotaMensualController.findByProjectId	Obtiene el historial de cuotas de un proyecto. Solo requiere autenticaci√≥n de usuario.
GET	/api/cuotas/:id_proyecto/last	authenticate	cuotaMensualController.findLastByProjectId	Obtiene el √∫ltimo registro de cuota. Solo requiere autenticaci√≥n de usuario.
PUT	/api/cuotas/:id	authenticate -> authorizeAdmin	cuotaMensualController.update	Actualizaci√≥n de cuota por ID. Requiere rol Admin.
DELETE	/api/cuotas/:id	authenticate -> authorizeAdmin	cuotaMensualController.softDelete	Eliminaci√≥n l√≥gica de cuota por ID. Requiere rol Admin.

Mapeo de Controladores: Gesti√≥n de Archivos (Im√°genes) (imagen.controller.js)
Este controlador administra la subida, consulta y eliminaci√≥n l√≥gica de las im√°genes asociadas a Proyectos y Lotes. Es notable por su dependencia del middleware de subida de archivos (imageUpload.middleware) y por el uso diferenciado de rutas para administradores y usuarios generales.

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
create	Sube un archivo de imagen y crea el registro en la BD.	1. Manejo de Archivos: Verifica que req.file exista (Multer lo adjunt√≥). 2. Validaci√≥n: La imagen debe estar asociada a id_proyecto o id_lote. 3. Registro: Utiliza req.file.path (ruta f√≠sica) como la URL para imagenService.create().	201 (Created): √âxito. 400 (Bad Request): Archivo faltante o sin asociaci√≥n.
getImagesByProjectId	Obtiene todas las im√°genes activas de un proyecto.	Llama a imagenService.findByProjectIdActivo(id_proyecto).	200 (OK). 400 (Bad Request): ID faltante.
getImagesByLoteId	Obtiene todas las im√°genes activas de un lote.	Llama a imagenService.findByLoteIdActivo(id_lote).	200 (OK). 400 (Bad Request): ID faltante.
findByIdActivo	Obtiene una imagen activa por su ID.	Llama a imagenService.findByIdActivo(id). Ruta utilizada por usuarios.	200 (OK). 404 (Not Found).
findById	Obtiene una imagen por ID (incluye inactivas).	Llama a imagenService.findById(id). Ruta utilizada exclusivamente por Administradores.	200 (OK). 404 (Not Found).
findAllActivo	Obtiene una lista de todas las im√°genes activas en el sistema.	Llama a imagenService.findAllActivo().	200 (OK).
findAll	Obtiene una lista de todas las im√°genes (incluye inactivas).	Llama a imagenService.findAll(). Solo para Administradores.	200 (OK).
update	Actualiza los metadatos de una imagen.	Llama a imagenService.update(id, data). No maneja la subida de un nuevo archivo de imagen.	200 (OK). 404 (Not Found).
softDelete	Marca una imagen como eliminada l√≥gicamente.	Llama a imagenService.softDelete(id) (asumido: activo: false).	200 (OK). 404 (Not Found).


7.9. Mapeo de Endpoints: routes/imagen.routes.js
El enrutamiento de im√°genes utiliza un orden espec√≠fico para manejar las rutas con prefijo (/proyecto/, /lote/, /admin/) antes que la ruta gen√©rica din√°mica (/:id). Las operaciones de escritura y consulta de datos sensibles est√°n restringidas al rol Admin.

M√©todo HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Prop√≥sito y Requisitos de Seguridad
POST	/api/imagenes/	authenticate -> authorizeAdmin -> imageUpload.single('image')	imagenController.create	Subida de imagen. Requiere Admin y el archivo en form-data con clave image.
GET	/api/imagenes/proyecto/:idProyecto	authenticate	imagenController.getImagesByProjectId	Im√°genes activas asociadas a un proyecto.
GET	/api/imagenes/lote/:idLote	authenticate	imagenController.getImagesByLoteId	Im√°genes activas asociadas a un lote.
GET	/api/imagenes/activas	authenticate	imagenController.findAllActivo	Lista todas las im√°genes activas (para cat√°logos).
GET	/api/imagenes/	authenticate -> authorizeAdmin	imagenController.findAll	Lista todas las im√°genes (incl. inactivas). Requiere Admin.
GET	/api/imagenes/admin/:id	authenticate -> authorizeAdmin	imagenController.findById	Obtiene imagen (activa/inactiva) por ID. Requiere Admin.
GET	/api/imagenes/:id	authenticate	imagenController.findByIdActivo	Obtiene imagen activa por ID. Ruta gen√©rica para usuarios.
PUT	/api/imagenes/:id	authenticate -> authorizeAdmin	imagenController.update	Actualizaci√≥n de metadatos. Requiere Admin.
DELETE	/api/imagenes/:id	authenticate -> authorizeAdmin	imagenController.softDelete	Eliminaci√≥n l√≥gica. Requiere Admin.

Mapeo de Controladores: Inversiones y Checkout Seguro (inversion.controller.js)
Este controlador maneja el ciclo de vida de una inversi√≥n, desde su creaci√≥n inicial (pendiente) hasta la solicitud de pago, implementando un punto de control de seguridad 2FA antes de la redirecci√≥n a la pasarela de pago.

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
create	Registra una nueva inversi√≥n en estado pendiente de pago.	Llama a inversionService.crearInversion(data). Solo registra la intenci√≥n y devuelve una URL sugerida para el pago.	201 (Created): √âxito. Devuelve el inversionId. 400 (Bad Request).
requestCheckoutInversion	Inicia el proceso de pago, actuando como control de seguridad 2FA.	1. Validaci√≥n: Verifica que la inversi√≥n exista, pertenezca al usuario y est√© pendiente. 2. Control 2FA: Si user.is_2fa_enabled es true, devuelve 202 (Accepted) e informa que se requiere la verificaci√≥n 2FA. El frontend debe detenerse y solicitar el c√≥digo. 3. Flujo Normal (Sin 2FA): Si 2FA est√° desactivado, llama a TransaccionService.iniciarTransaccionYCheckout() y devuelve la redirectUrl a la pasarela.	200 (OK): Redirecci√≥n directa a la pasarela. 202 (Accepted): 2FA requerido. 403 (Forbidden): Inversi√≥n no v√°lida o no pertenece al usuario.
confirmarInversionCon2FA	Ejecuta la transacci√≥n solo despu√©s de verificar el c√≥digo 2FA.	1. Verificaci√≥n: Llama a auth2faService.verifyToken() usando el codigo_2fa proporcionado y el twofa_secret del usuario. 2. Ejecuci√≥n: Si la verificaci√≥n 2FA es exitosa (c√≥digo 200), procede a llamar a TransaccionService.iniciarTransaccionYCheckout() para generar la transacci√≥n y la redirectUrl.	200 (OK): Verificaci√≥n exitosa. Devuelve redirectUrl. 401 (Unauthorized): C√≥digo 2FA incorrecto. 403 (Forbidden): Inversi√≥n o estado no v√°lidos.
findMyInversions	Obtiene todas las inversiones del usuario autenticado.	Llama a inversionService.findByUserId(userId).	200 (OK).
findMyInversionById	Obtiene una inversi√≥n espec√≠fica verificando que pertenezca al usuario.	Llama a inversionService.findByIdAndUserId(id, userId).	200 (OK). 404 (Not Found).
findAll	Obtiene todas las inversiones (incluye inactivas).	Llama a inversionService.findAll(). Solo para Administradores.	200 (OK).
softDeleteMyInversion	Elimina l√≥gicamente una inversi√≥n (si a√∫n est√° en estado pendiente).	Llama a inversionService.softDeleteByIdAndUserId(id, userId). Solo puede eliminar sus propias inversiones.	204 (No Content): Eliminaci√≥n exitosa. 404 (Not Found).
softDelete	Elimina l√≥gicamente una inversi√≥n (funci√≥n de Admin).	Llama a inversionService.softDelete(id). Solo para Administradores.	204 (No Content): Eliminaci√≥n exitosa. 404 (Not Found).


7.11. Mapeo de Endpoints: routes/inversion.routes.js
El enrutamiento de Inversiones es cr√≠tico debido a la secuencia de pasos de pago y la seguridad del 2FA. La mayor√≠a de las rutas est√°n protegidas por authMiddleware.authenticate.

M√©todo HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Prop√≥sito y Requisitos de Seguridad
POST	/api/inversion/	authenticate	inversionController.create	Registro inicial de la inversi√≥n (estado pendiente).
POST	/api/inversion/iniciar-pago/:idInversion	authenticate	inversionController.requestCheckoutInversion	Paso 1 del checkout. Decide si se requiere 2FA o redirige.
POST	/api/inversion/confirmar-2fa	authenticate	inversionController.confirmarInversionCon2FA	Paso 2 del checkout. Verifica el c√≥digo 2FA y ejecuta la redirecci√≥n.
GET	/api/inversion/mis_inversiones	authenticate	inversionController.findMyInversions	Lista todas las inversiones del usuario logueado.
GET	/api/inversion/	authenticate -> authorizeAdmin	inversionController.findAll	Lista todas las inversiones (incl. inactivas). Requiere Admin.
GET	/api/inversion/activas	authenticate -> authorizeAdmin	inversionController.findAllActivo	Lista solo inversiones activas. Requiere Admin.
GET	/api/inversion/:id	authenticate	inversionController.findById	Obtiene inversi√≥n por ID (Admin) o verifica posesi√≥n.
PUT	/api/inversion/:id	authenticate -> authorizeAdmin	inversionController.update	Actualizaci√≥n de inversi√≥n. Requiere Admin.
DELETE	/api/inversion/:id	authenticate -> authorizeAdmin	inversionController.softDelete	Eliminaci√≥n l√≥gica de inversi√≥n. Requiere Admin.

Mapeo de Controladores: Gesti√≥n de Lotes y Subastas (lote.controller.js)
Este controlador maneja la creaci√≥n y el mantenimiento de los lotes de inversi√≥n y contiene la l√≥gica compleja para iniciar y finalizar el proceso de subasta asociado a cada lote.

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
create	Crea un nuevo lote de inversi√≥n.	Llama a loteService.create(data).	201 (Created). 400 (Bad Request).
findAllActivo	Obtiene todos los lotes disponibles para inversi√≥n (activos).	Llama a loteService.findAllActivo().	200 (OK).
findByIdActivo	Obtiene un lote espec√≠fico, solo si est√° activo.	Llama a loteService.findByIdActivo(id).	200 (OK). 404 (Not Found).
findAll	Obtiene todos los lotes (incluyendo inactivos).	Llama a loteService.findAll(). Solo para Administradores.	200 (OK).
findById	Obtiene un lote por ID (incluye inactivos).	Llama a loteService.findById(id). Solo para Administradores.	200 (OK). 404 (Not Found).
update	Actualiza los datos de un lote.	Llama a loteService.update(id, data).	200 (OK). 404 (Not Found).
softDelete	Elimina l√≥gicamente un lote.	Llama a loteService.softDelete(id).	200 (OK). 404 (Not Found).
startAuction	Inicia el proceso de subasta para un lote.	1. Actualiza estado_subasta a 'activa' y fecha_inicio. 2. CR√çTICO: Utiliza SuscripcionProyectoService para obtener usuarios suscritos al proyecto. 3. Env√≠a un mensaje de notificaci√≥n a todos los suscriptores a trav√©s de mensajeService.crear().	200 (OK). 404 (Not Found): Lote o Proyecto.
endAuction	Finaliza la subasta, determina el ganador y genera la transacci√≥n.	1. Llama a la l√≥gica compleja de loteService.endAuction(id). 2. Si hay un ganador (hubo pujas), devuelve la transaccion creada para que el ganador proceda al pago.	200 (OK): Finalizaci√≥n exitosa (con o sin ganador). 400 (Bad Request): Error en la l√≥gica de finalizaci√≥n.


7.13. Mapeo de Endpoints: routes/lote.routes.js
Las rutas de lotes balancean el acceso p√∫blico a la informaci√≥n de inversi√≥n activa y la restricci√≥n a las operaciones de control de subasta y mantenimiento, que son exclusivas de los administradores.

M√©todo HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Prop√≥sito y Requisitos de Seguridad
POST	/api/lotes/	authenticate -> authorizeAdmin	loteController.create	Creaci√≥n de lotes. Requiere Admin.
GET	/api/lotes/activos	authenticate	loteController.findAllActivo	Lista todos los lotes activos (para la secci√≥n de inversi√≥n p√∫blica).
GET	/api/lotes/	authenticate -> authorizeAdmin	loteController.findAll	Lista todos los lotes (incl. inactivos). Requiere Admin.
POST	/api/lotes/:id/start_auction	authenticate -> authorizeAdmin	loteController.startAuction	Inicia la subasta de un lote. Requiere Admin.
PUT	/api/lotes/:id/end	authenticate -> authorizeAdmin	loteController.endAuction	Finaliza la subasta de un lote. Requiere Admin.
GET	/api/lotes/:id/activo	authenticate	loteController.findByIdActivo	Obtiene un lote espec√≠fico solo si est√° activo.
GET	/api/lotes/:id	authenticate -> authorizeAdmin	loteController.findById	Obtiene un lote por ID (activos/inactivos). Requiere Admin.
PUT	/api/lotes/:id	authenticate -> authorizeAdmin	loteController.update	Actualizaci√≥n de lote. Requiere Admin.
DELETE	/api/lotes/:id	authenticate -> authorizeAdmin	loteController.softDelete	Eliminaci√≥n l√≥gica de lote. Requiere Admin.

Mapeo de Controladores: Mensajer√≠a Interna (mensaje.controller.js)
Este controlador administra la funcionalidad de mensajer√≠a privada, permitiendo a los usuarios enviar, recibir, contar y marcar mensajes como le√≠dos. Todas las operaciones requieren autenticaci√≥n.

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
obtenerMisMensajes	Obtiene la lista completa de mensajes recibidos y enviados por el usuario autenticado.	Llama a mensajeService.obtenerPorUsuario(userId).	200 (OK).
enviarMensaje	Permite al usuario autenticado enviar un mensaje a otro usuario.	Obtiene el id_remitente de req.user.id. Llama a mensajeService.crear().	201 (Created): √âxito. 400 (Bad Request).
obtenerConteoNoLeidos	Proporciona el n√∫mero de mensajes no le√≠dos para el usuario autenticado.	Llama a mensajeService.contarNoLeidos(userId).	200 (OK). Devuelve un objeto { conteo: N }.
obtenerConversacion	Recupera el historial de mensajes entre el usuario autenticado y un receptor espec√≠fico.	Llama a mensajeService.obtenerConversacion(userId, id_receptor).	200 (OK).
marcarComoLeido	Marca un mensaje espec√≠fico como le√≠do por el usuario.	Llama a mensajeService.marcarComoLeido(id, userId). CR√çTICO: Valida que el mensaje sea recibido por el usuario que intenta marcarlo.	200 (OK). 404 (Not Found): Mensaje no existe o no es del usuario.


7.15. Mapeo de Endpoints: routes/mensaje.routes.js
Todas las rutas del sistema de mensajer√≠a est√°n protegidas por el middleware de autenticaci√≥n (authMiddleware.authenticate) para asegurar la privacidad de la comunicaci√≥n. Es crucial el orden de las rutas est√°ticas antes que las din√°micas.

M√©todo HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Prop√≥sito y Requisitos de Seguridad
GET	/api/mensajes/	authenticate	mensajeController.obtenerMisMensajes	Lista todos los mensajes del usuario (Bandeja de entrada/salida).
POST	/api/mensajes/	authenticate	mensajeController.enviarMensaje	Env√≠o de un nuevo mensaje.
GET	/api/mensajes/no_leidos	authenticate	mensajeController.obtenerConteoNoLeidos	Obtiene el n√∫mero de mensajes no le√≠dos.
PUT	/api/mensajes/leido/:id	authenticate	mensajeController.marcarComoLeido	Marca un mensaje por ID como le√≠do.
GET	/api/mensajes/:id_receptor	authenticate	mensajeController.obtenerConversacion	Obtiene la conversaci√≥n con el usuario especificado.

Mapeo de Controladores: Gesti√≥n de Pagos y Checkout con 2FA (pago.controller.js)
Este controlador maneja la funcionalidad de pagos, desde la consulta personal y administrativa hasta el proceso cr√≠tico de checkout, que utiliza un flujo de bifurcaci√≥n de seguridad para los usuarios con 2FA activo.

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
requestCheckout	Inicia el proceso de pago para un registro existente.	1. Validaci√≥n: Llama a pagoService.getValidPaymentDetails(pagoId, userId) para verificar la propiedad y estado. 2. Control 2FA: Si user.is_2fa_enabled es true, devuelve 202 (Accepted) indicando que se requiere el c√≥digo 2FA. 3. Flujo Normal: Si no hay 2FA, llama a transaccionService.iniciarTransaccionYCheckout() y devuelve la redirectUrl.	200 (Redirecci√≥n). 202 (2FA Requerido). 403 (No autorizado). 409 (Conflicto/Pago ya procesado).
confirmarPagoYContinuar	Contin√∫a el checkout despu√©s de la verificaci√≥n exitosa del 2FA.	1. Verificaci√≥n: Llama a auth2faService.verifyToken() con el c√≥digo proporcionado. 2. Ejecuci√≥n: Si es correcto, llama a transaccionService.iniciarTransaccionYCheckout() para generar la transacci√≥n y la redirectUrl.	200 (Redirecci√≥n). 401 (C√≥digo 2FA incorrecto). 403 (2FA no activo).
findMyPayments	Obtiene la lista de todos los pagos realizados por el usuario autenticado.	Llama a pagoService.findByUserId(userId).	200 (OK).
triggerManualPayment	Genera manualmente un pago a partir de una suscripci√≥n.	Llama a pagoService.generarPagoMensualConDescuento(id_suscripcion). Funci√≥n administrativa para generar pagos a demanda.	201 (Created). 400 (Falta ID).
findAll	Obtiene la lista de todos los pagos en el sistema.	Llama a pagoService.findAll(). Solo para Administradores.	200 (OK).
findById	Obtiene un pago espec√≠fico por ID.	Llama a pagoService.findById(id). Solo para Administradores.	200 (OK). 404 (Not Found).
update	Actualiza los datos de un pago.	Llama a pagoService.update(id, data). Solo para Administradores.	200 (OK). 404 (Not Found).
softDelete	Elimina l√≥gicamente un pago.	Llama a pagoService.softDelete(id). Solo para Administradores.	200 (OK). 404 (Not Found).


7.17. Mapeo de Endpoints: routes/pago.routes.js
El enrutamiento de Pagos prioriza la seguridad y el flujo del checkout. Es fundamental que las rutas est√°ticas de usuario (/mis_pagos) y de control de flujo (/confirmar-pago-2fa) se definan antes que las rutas din√°micas gen√©ricas.

M√©todo HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Prop√≥sito y Requisitos de Seguridad
GET	/api/pagos/mis_pagos	authenticate	pagoController.findMyPayments	Consulta los pagos del usuario logueado.
POST	/api/pagos/pagar-mes/:id	authenticate	pagoController.requestCheckout	Paso 1 del checkout. Inicia el proceso de pago y verifica si se necesita 2FA.
POST	/api/pagos/confirmar-pago-2fa	authenticate	pagoController.confirmarPagoYContinuar	Paso 2 del checkout. Verifica el c√≥digo 2FA y redirige a la pasarela.
GET	/api/pagos/	authenticate -> authorizeAdmin	pagoController.findAll	Lista todos los pagos. Requiere Admin.
POST	/api/pagos/trigger-manual-payment	authenticate -> authorizeAdmin	pagoController.triggerManualPayment	Generaci√≥n manual/simulada de un pago. Requiere Admin.
GET	/api/pagos/:id	authenticate -> authorizeAdmin	pagoController.findById	Obtiene un pago espec√≠fico por ID. Requiere Admin.
PUT	/api/pagos/:id	authenticate -> authorizeAdmin	pagoController.update	Actualizaci√≥n de pago. Requiere Admin.
DELETE	/api/pagos/:id	authenticate -> authorizeAdmin	pagoController.softDelete	Eliminaci√≥n l√≥gica de pago. Requiere Admin.

¬°Excelente elecci√≥n! El controlador de Pagos (Mercado Pago) es el m√°s cr√≠tico a nivel de infraestructura, ya que gestiona la comunicaci√≥n segura y as√≠ncrona con la pasarela de pago, implementando validaciones criptogr√°ficas.

Aqu√≠ tienes la documentaci√≥n detallada.

7.18. Mapeo de Controladores: Pagos y Pasarela (Mercado Pago) (pagoMercado.controller.js)
Este controlador centraliza toda la l√≥gica relacionada con la creaci√≥n de checkouts, la gesti√≥n de webhooks (notificaciones as√≠ncronas) y la consulta de estados, asegurando la integridad de las transacciones mediante un control estricto de seguridad.

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
verifySignature	CR√çTICA DE SEGURIDAD: Verifica la autenticidad de las notificaciones entrantes de Mercado Pago (Webhooks) utilizando el algoritmo HMAC-SHA256 y la clave secreta configurada.	Interna. Rechaza cualquier solicitud de webhook que no tenga una firma criptogr√°fica v√°lida, protegiendo contra la suplantaci√≥n de identidad.	N/A (Interna).
iniciarPagoPorModelo	Ruta Est√°ndar: Inicia el proceso de checkout para cualquier modelo pendiente de pago (Inversi√≥n, Puja, etc.) de forma gen√©rica.	Llama a transaccionService.iniciarTransaccionYCheckout(modelo, modeloId, userId).	200 (OK): Devuelve redirectUrl. 400 (IDs inv√°lidos).
createCheckoutGenerico	Ruta Avanzada: Crea una nueva Transacci√≥n y su checkout MP, o regenera un checkout para una Transacci√≥n existente.	Utiliza una Transacci√≥n de BD para asegurar atomicidad. Llama a transaccionService.crearTransaccionConCheckout.	200 (OK): Devuelve redirectUrl. 500 (Error de servidor/BD).
handleWebhook	Procesamiento de Webhooks: Maneja las notificaciones de estado enviadas por Mercado Pago.	1. Llama a verifySignature (si falla, devuelve 401). 2. Procesa merchant_order (para actualizar m√∫ltiples pagos) o payment. 3. Si es un pago aprobado, llama a transaccionService.confirmarTransaccion dentro de una Transacci√≥n de BD con bloqueo (LOCK.UPDATE) para evitar duplicados.	200 (OK): Siempre responde 200 a MP (incluso si hay un error de procesamiento interno) para evitar reintentos. 401 (Unauthorized): Firma Inv√°lida.
handleCheckoutRedirect	Maneja la redirecci√≥n del usuario (GET) despu√©s de interactuar con la pasarela de pago (Mercado Pago).	Revisa el estado de la URL (collection_status). Si el usuario rechaza/cancela el pago, llama a transaccionService.cancelarTransaccionPorUsuario y redirige al frontend a la p√°gina de fallo.	302 (Redirect): A la URL del frontend (/pago-estado o /pago-fallido).
getPaymentStatus	Permite al usuario autenticado consultar el estado final de una transacci√≥n.	Verifica que la Transacci√≥n pertenezca al usuario. Si se solicita refresh=true y la transacci√≥n est√° en proceso, llama a pagoMercadoService.refreshPaymentStatus para obtener el estado m√°s reciente de la pasarela.	200 (OK): Devuelve el estado y los detalles de pago. 404 (No encontrado/No pertenece).
createCheckout	Flujo de compatibilidad con inversiones (envoltorio de createCheckoutGenerico).	Busca la inversi√≥n, valida su estado pendiente, y delega en createCheckoutGenerico.	200 (OK). 404 (Inversi√≥n no encontrada).


7.19. Mapeo de Endpoints: routes/pagoMercado.routes.js
Estas rutas requieren autenticaci√≥n, salvo las dos rutas p√∫blicas (/webhook y /redirect) que deben ser accesibles para la pasarela de pago.

M√©todo HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Prop√≥sito y Requisitos de Seguridad
POST	/api/payment/checkout/:modelo/:modeloId	authenticate	paymentController.iniciarPagoPorModelo	Flujo Est√°ndar: Inicia el pago para un registro (ej. /inversion/5).
POST	/api/payment/checkout/generico	authenticate	paymentController.createCheckoutGenerico	Flujo avanzado: Crea/Regenera una Transacci√≥n y Checkout.
POST	/api/payment/checkout	authenticate	paymentController.createCheckout	Flujo de compatibilidad (Inversiones).
GET	/api/payment/status/:id_transaccion	authenticate	paymentController.getPaymentStatus	Consulta el estado final de una transacci√≥n (con opci√≥n de refresco).
GET	/api/payment/redirect	N/A (Ruta de retorno de la pasarela)	paymentController.handleCheckoutRedirect	Redirige al usuario al frontend despu√©s del pago.
POST	/webhook/:metodo	N/A (Definida en el nivel m√°s alto, ej., server.js)	paymentController.handleWebhook	Recepci√≥n de Webhooks de MP. Abierta al p√∫blico (la seguridad se garantiza con la firma criptogr√°fica).


Mapeo de Controladores: Gesti√≥n de Proyectos (proyecto.controller.js)
Este controlador maneja la creaci√≥n y el mantenimiento de los proyectos de inversi√≥n, incluyendo la l√≥gica compleja para vincular lotes y notificar a los usuarios sobre nuevos proyectos. Gran parte de la funcionalidad CRUD est√° restringida a administradores, mientras que las funciones de consulta de proyectos "activos" est√°n disponibles para cualquier usuario autenticado.

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
findAllActivo	Obtiene todos los proyectos que est√°n activos y visibles para inversi√≥n.	Llama a proyectoService.findAllActivo().	200 (OK).
findByIdActivo	Obtiene un proyecto espec√≠fico, solo si est√° activo.	Llama a proyectoService.findByIdActivo(id).	200 (OK). 404 (Not Found).
findMyProjects	Obtiene una lista √∫nica de proyectos en los que el usuario ha invertido o est√° suscrito.	L√≥gica de combinaci√≥n: Usa suscripcionProyectoService.findByUserId y inversionService.findByUserId.	200 (OK).
create	Crea un nuevo proyecto.	CR√çTICA: Ejecuta una Transacci√≥n de BD para asegurar la atomicidad de: 1. Creaci√≥n del Proyecto. 2. Asociaci√≥n de lotesIds al nuevo proyecto. 3. Env√≠o de un mensaje de notificaci√≥n general a todos los usuarios activos.	201 (Created). 400 (Bad Request).
update	Actualiza un proyecto existente.	Ejecuta una Transacci√≥n de BD para actualizar el proyecto y reasociar la lista de lotes (loteService.updateLotesProyecto).	200 (OK). 404 (Not Found).
softDelete	"Elimina" un proyecto (soft delete).	Llama a proyectoService.softDelete(id).	200 (OK). 404 (Not Found).
findAll	Obtiene todos los proyectos (incluye inactivos y eliminados l√≥gicamente).	Llama a proyectoService.findAll(). Solo para Administradores.	200 (OK).
findById	Obtiene un proyecto por ID (incluye inactivos).	Llama a proyectoService.findById(id). Solo para Administradores.	200 (OK). 404 (Not Found).
endAuction	(Funci√≥n de Lote) Finaliza la subasta de un lote de ese proyecto.	Llama a loteService.endAuction(id). (L√≥gica cr√≠tica de asignaci√≥n de ganador).	200 (OK). 400 (Bad Request).


7.21. Mapeo de Endpoints: routes/proyecto.routes.js
El enrutamiento de proyectos se organiza para que las rutas de consumo masivo (/activos) est√©n definidas antes que las rutas din√°micas, lo que asegura un correcto enrutamiento. Las rutas de Administraci√≥n requieren autenticaci√≥n y la validaci√≥n de rol (authorizeAdmin).

M√©todo HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Prop√≥sito y Requisitos de Seguridad
GET	/api/proyectos/activos	authenticate	proyectoController.findAllActivo	Lista todos los proyectos activos para inversi√≥n (Consumo p√∫blico).
POST	/api/proyectos/	authenticate -> authorizeAdmin	proyectoController.create	Creaci√≥n de un nuevo proyecto. Requiere Admin.
GET	/api/proyectos/	authenticate -> authorizeAdmin	proyectoController.findAll	Lista todos los proyectos (CRUD Admin). Requiere Admin.
GET	/api/proyectos/:id/activo	authenticate	proyectoController.findByIdActivo	Obtiene un proyecto por ID, solo si est√° activo.
GET	/api/proyectos/:id	authenticate -> authorizeAdmin	proyectoController.findById	Obtiene cualquier proyecto por ID (CRUD Admin). Requiere Admin.
PUT	/api/proyectos/:id	authenticate -> authorizeAdmin	proyectoController.update	Actualizaci√≥n de proyecto. Requiere Admin.
DELETE	/api/proyectos/:id	authenticate -> authorizeAdmin	proyectoController.softDelete	Eliminaci√≥n l√≥gica de proyecto. Requiere Admin.

Mapeo de Controladores: Gesti√≥n de Pujas y Checkout 2FA (puja.controller.js)
Este controlador administra la funcionalidad de las pujas, desde su creaci√≥n y consulta personal hasta el flujo de pago que se activa cuando un usuario resulta ganador de una subasta y debe pagar el lote.

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
create	Crea una nueva puja en un lote activo.	Llama a pujaService.create(), asegurando que la puja se asigne al req.user.id.	201 (Created). 400 (Monto/Lote inv√°lido).
requestCheckout	Inicia el proceso de pago para una puja ganadora.	Bifurcaci√≥n 2FA: Si el usuario tiene 2FA activo, devuelve 202 solicitando el c√≥digo. Si no, genera el checkout llamando a pujaService.requestCheckoutForPuja().	200 (Redirecci√≥n). 202 (2FA Requerido). 403 (No autorizado). 409 (Puja no est√° en estado "ganadora pendiente").
confirmarPujaCon2FA	Verifica el c√≥digo 2FA y, si es correcto, contin√∫a con el checkout de la puja.	CR√çTICA: Llama a auth2faService.verifyToken(). Si la verificaci√≥n es exitosa, llama a pujaService.requestCheckoutForPuja() para generar la Transacci√≥n.	200 (Redirecci√≥n). 401 (C√≥digo 2FA incorrecto). 403 (2FA no activo).
manageAuctionEnd	Funci√≥n interna de administraci√≥n para ejecutar la l√≥gica final de una subasta.	Llama a pujaService.gestionarTokensAlFinalizar(id_lote) para gestionar los tokens y la asignaci√≥n final del lote. Solo para Administradores.	200 (OK). 400 (Datos faltantes).
findMyPujas	Obtiene todas las pujas que el usuario autenticado ha realizado.	Llama a pujaService.findByUserId(userId).	200 (OK).
findAllActivo	Obtiene todas las pujas activas en la plataforma.	Llama a pujaService.findAllActivo().	200 (OK).
findAll	Obtiene todas las pujas del sistema.	Llama a pujaService.findAll(). Solo para Administradores.	200 (OK).
CRUD Gen√©rico/Mi Puja	Funciones CRUD para Administradores o para acciones espec√≠ficas del usuario (findMyPujaById, softDeleteMyPuja, etc.).	Realizan operaciones b√°sicas de consulta/modificaci√≥n, validando la propiedad en el caso de las rutas de usuario.	200 (OK) / 204 (No Content) / 404 (Not Found).


7.23. Mapeo de Endpoints: routes/puja.routes.js
El orden de las rutas es especialmente sensible aqu√≠ para priorizar las rutas del usuario (/mis_pujas) y los flujos de checkout antes de que el par√°metro din√°mico :id general capture las peticiones.

M√©todo HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Prop√≥sito y Requisitos de Seguridad
POST	/api/pujas/	authenticate	pujaController.create	Crea una nueva puja.
GET	/api/pujas/activas	authenticate	pujaController.findAllActivo	Lista todas las pujas que est√°n en subastas activas.
GET	/api/pujas/mis_pujas	authenticate	pujaController.findMyPujas	Lista las pujas del usuario autenticado.
GET	/api/pujas/mis_pujas/:id	authenticate	pujaController.findMyPujaById	Obtiene una puja espec√≠fica del usuario.
DELETE	/api/pujas/mis_pujas/:id	authenticate	pujaController.softDeleteMyPuja	Elimina una puja del usuario.
POST	/api/pujas/iniciar-pago/:id	authenticate	pujaController.requestCheckout	Paso 1 Checkout: Inicia el pago de la puja ganadora y gestiona la bifurcaci√≥n 2FA.
POST	/api/pujas/confirmar-2fa	authenticate	pujaController.confirmarPujaCon2FA	Paso 2 Checkout: Verifica el c√≥digo 2FA y contin√∫a con la generaci√≥n del checkout.
GET	/api/pujas/	authenticate -> authorizeAdmin	pujaController.findAll	Lista todas las pujas (Admin).
POST	/api/pujas/gestionar_finalizacion	authenticate -> authorizeAdmin	pujaController.manageAuctionEnd	Punto de control para gestionar tokens al finalizar subasta. Requiere Admin.
GET	/api/pujas/:id	authenticate -> authorizeAdmin	pujaController.findById	Obtiene una puja por ID (Admin).
PUT	/api/pujas/:id	authenticate -> authorizeAdmin	pujaController.update	Actualiza una puja por ID (Admin).
DELETE	/api/pujas/:id	authenticate -> authorizeAdmin	pujaController.softDelete	Elimina una puja por ID (Admin).

Mapeo de Controladores: Redirecci√≥n Post-Pago (redireccion.controller.js)
Este controlador se encarga de recibir las peticiones de retorno (GET) enviadas por la pasarela de pago despu√©s de que el usuario interact√∫a con ella. Su √∫nica funci√≥n es actualizar el estado de la transacci√≥n si es un fallo/cancelaci√≥n y redirigir al usuario al frontend con el estado correspondiente.

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
handleFailure	Procesa el retorno del usuario por fallo o cancelaci√≥n de la operaci√≥n de pago.	CR√çTICA: Llama a transaccionService.cancelarTransaccionPorUsuario(id) para marcar la transacci√≥n interna como fallido. Redirige al frontend (/payment-result/:id?status=failure).	302 (Redirect) a Frontend URL.
handleSuccess	Procesa el retorno del usuario por √©xito en la pasarela.	Asunci√≥n: El estado final de pagado se actualizar√° por el Webhook (proceso as√≠ncrono y seguro). Esta funci√≥n solo redirige al usuario a la vista de √©xito (/payment-result/:id?status=success).	302 (Redirect) a Frontend URL.
handlePending	Procesa el retorno del usuario por estado pendiente en la pasarela.	Redirige al usuario a la vista de estado pendiente, sugiriendo la consulta de estado posterior (/payment-result/:id?status=pending).	302 (Redirect) a Frontend URL.


7.25. Mapeo de Endpoints: Redirecci√≥n (redireccion.routes.js)
Estas rutas son p√∫blicas y deben estar expuestas directamente para que la pasarela de pago pueda enviar el navegador del usuario de vuelta al servidor tras completar la interacci√≥n.

M√©todo HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Prop√≥sito y Requisitos de Seguridad
GET	/pago/exito/:id	N/A (P√∫blico)	redireccionController.handleSuccess	Retorno de pasarela en caso de √©xito.
GET	/pago/fallo/:id	N/A (P√∫blico)	redireccionController.handleFailure	Retorno de pasarela en caso de fallo o cancelaci√≥n por el usuario.
GET	/pago/pendiente/:id	N/A (P√∫blico)	redireccionController.handlePending	Retorno de pasarela en caso de que el pago quede en proceso (ej. efectivo).


 Mapeo de Controladores: Resumen de Cuenta (resumen_cuenta.controller.js)
Este controlador es responsable de generar los res√∫menes detallados de las cuentas de inversi√≥n/suscripci√≥n, calcular las cuotas mensuales (basadas en valores din√°micos como el cemento) y proporcionar acceso a los usuarios a sus propios res√∫menes, mientras reserva el control CRUD completo para los administradores.

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
create	Creaci√≥n y C√°lculo: Crea un nuevo resumen de cuenta.	CR√çTICA: Depende de cuotaMensualService.createAndSetProjectAmount para calcular el valor m√≥vil y el valor mensual final basado en el precio del cemento y los porcentajes de plan/IVA. Crea el ResumenCuenta con estos detalles.	201 (Created). 404 (Proyecto no encontrado). 500 (Error de c√°lculo/BD).
findMyAccountSummaries	Obtiene todos los res√∫menes de cuenta del usuario autenticado.	Llama a resumenCuentaService.getAccountSummariesByUserId(userId).	200 (OK).
findAll	Obtiene todos los res√∫menes de cuenta del sistema.	Llama a resumenCuentaService.findAll(). Solo para Administradores.	200 (OK).
getAccountSummaryById	Obtiene un resumen espec√≠fico.	Control de Acceso: Verifica si el usuario es Administrador (acceso total) o si es el propietario del resumen (findResumenByIdAndUserId).	200 (OK). 404 (No encontrado o no autorizado).
update	Actualiza manualmente un resumen de cuenta.	Llama a resumenCuentaService.update(). Solo para Administradores.	200 (OK). 404 (Not Found).
softDelete	Elimina l√≥gicamente un resumen de cuenta.	Llama a resumenCuentaService.softDelete(). Solo para Administradores.	200 (OK). 404 (Not Found).


7.27. Mapeo de Endpoints: Resumen de Cuenta (resumen_cuenta.routes.js)
Las rutas est√°n dise√±adas para diferenciar claramente entre el acceso del usuario final (lectura de sus res√∫menes) y las operaciones de administraci√≥n (CRUD total), utilizando authMiddleware.authorizeAdmin.

M√©todo HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Prop√≥sito y Requisitos de Seguridad
GET	/api/resumen_cuenta/mis_resumenes	authenticate	resumenCuentaController.findMyAccountSummaries	Obtiene la lista de res√∫menes del usuario. (Lectura para el cliente).
GET	/api/resumen_cuenta/	authenticate -> authorizeAdmin	resumenCuentaController.findAll	Lista todos los res√∫menes (CRUD Admin). Requiere Admin.
GET	/api/resumen_cuenta/:id	authenticate	resumenCuentaController.getAccountSummaryById	Obtiene un resumen espec√≠fico, verificando la propiedad o el rol de Admin.
PUT	/api/resumen_cuenta/:id	authenticate -> authorizeAdmin	resumenCuentaController.update	Actualiza un resumen por ID. Requiere Admin.
DELETE	/api/resumen_cuenta/:id	authenticate -> authorizeAdmin	resumenCuentaController.softDelete	Eliminaci√≥n l√≥gica de un resumen. Requiere Admin.

Mapeo de Controladores: Suscripci√≥n de Proyecto (suscripcion_proyecto.controller.js)
Este controlador maneja el proceso de suscripci√≥n a un proyecto de inversi√≥n, desde el pago inicial (con validaci√≥n 2FA) hasta la creaci√≥n del registro de la suscripci√≥n y su posterior gesti√≥n.

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
iniciarSuscripcion	Inicia la transacci√≥n de pago para la inversi√≥n inicial del proyecto.	CR√çTICA (Transacci√≥n y 2FA): 1. Verifica si el proyecto es v√°lido. 2. Si el usuario tiene 2FA activo, crea la Transacci√≥n y el Pago como pendiente en una transacci√≥n de BD, y devuelve 202 (requiere 2FA). 3. Si no hay 2FA, genera la URL de checkout de la pasarela y devuelve 200 con la URL.	200 (Redirecci√≥n). 202 (2FA Requerido). 400 (Proyecto finalizado). 404 (Proyecto no encontrado).
confirmarSuscripcionCon2FA	Verifica el c√≥digo 2FA para un pago de suscripci√≥n pendiente.	CR√çTICA: Llama a auth2faService.verifyToken. Si es exitoso, llama a TransaccionService.generarCheckoutParaTransaccionExistente para crear la preferencia de pago y devolver la URL de redirecci√≥n.	200 (Redirecci√≥n). 401 (C√≥digo 2FA incorrecto). 403 (Transacci√≥n inv√°lida/no pertenece).
confirmarSuscripcion	Endpoint Webhook llamado por la pasarela de pago para notificar el pago exitoso.	CR√çTICA: Llama a suscripcionProyectoService.confirmarSuscripcion(transaccionId). Esta funci√≥n es responsable de crear el registro de la suscripci√≥n y el Resumen de Cuenta (si aplica) una vez que el pago ha sido validado por el webhook.	200 (OK - respuesta al webhook). 400 (ID de transacci√≥n faltante).
findMySubscriptions	Obtiene todas las suscripciones activas del usuario.	Llama a suscripcionProyectoService.findByUserId(userId).	200 (OK).
findMySubscriptionById	Obtiene una suscripci√≥n espec√≠fica del usuario.	Llama a suscripcionProyectoService.findByIdAndUserId(id, userId).	200 (OK). 404 (No encontrada o no pertenece).
softDeleteMySubscription	Cancela (soft delete) una suscripci√≥n del usuario.	Verifica que la suscripci√≥n pertenezca al usuario antes de llamar a suscripcionProyectoService.softDelete().	200 (OK). 404 (No encontrada o no pertenece).
findAll / findById	Funciones CRUD para administradores.	Acceso completo a todas las suscripciones. Requiere Admin.	200 (OK). 404 (Not Found).


7.29. Mapeo de Endpoints: Suscripci√≥n de Proyecto (suscripcion_proyecto.routes.js)
Las rutas reflejan el flujo de pago con 2FA y separan claramente los accesos de usuario (/mis_suscripciones) de las funcionalidades de administraci√≥n.

M√©todo HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Prop√≥sito y Requisitos de Seguridad
POST	/api/suscripciones/iniciar-pago	authenticate	suscripcionProyectoController.iniciarSuscripcion	Paso 1 Checkout: Inicia la transacci√≥n de pago y gestiona la bifurcaci√≥n 2FA.
POST	/api/suscripciones/confirmar-2fa	authenticate	suscripcionProyectoController.confirmarSuscripcionCon2FA	Paso 2 Checkout: Verifica el c√≥digo 2FA y genera la URL de redirecci√≥n.
GET	/api/suscripciones/activas	authenticate	suscripcionProyectoController.findAllActivo	Lista las suscripciones activas a proyectos.
GET	/api/suscripciones/mis_suscripciones	authenticate	suscripcionProyectoController.findMySubscriptions	Lista las suscripciones del usuario.
GET	/api/suscripciones/mis_suscripciones/:id	authenticate	suscripcionProyectoController.findMySubscriptionById	Obtiene una suscripci√≥n espec√≠fica del usuario.
DELETE	/api/suscripciones/mis_suscripciones/:id	authenticate	suscripcionProyectoController.softDeleteMySubscription	Cancela una suscripci√≥n del usuario.
POST	/api/suscripciones/confirmar-pago	N/A (P√∫blico)	suscripcionProyectoController.confirmarSuscripcion	Webhook: Punto de entrada para la pasarela de pago para confirmar pagos.
GET	/api/suscripciones/	authenticate -> authorizeAdmin	suscripcionProyectoController.findAll	Lista todas las suscripciones (Admin).
GET	/api/suscripciones/:id	authenticate -> authorizeAdmin	suscripcionProyectoController.findById	Obtiene una suscripci√≥n por ID (Admin).
DELETE	/api/suscripciones/:id	authenticate -> authorizeAdmin	suscripcionProyectoController.softDelete	Eliminaci√≥n l√≥gica de una suscripci√≥n (Admin).


Mapeo de Controladores: Gesti√≥n de Suscripciones Gen√©ricas (suscripcion.controller.js)
Este controlador est√° dise√±ado para una √∫nica tarea: permitir que un usuario autenticado cancele una suscripci√≥n existente, asegurando que solo pueda modificar su propia informaci√≥n.

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
cancel	Permite a un usuario realizar una eliminaci√≥n l√≥gica (soft delete) de su propia suscripci√≥n.	Control de Acceso: Realiza una verificaci√≥n estricta para asegurar que el id_usuario de la suscripci√≥n coincida con el req.user.id del usuario autenticado. Llama a suscripcionService.softDelete(id).	200 (OK). 403 (Acceso denegado: no es el propietario). 400 (Error de servicio).


7.31. Mapeo de Endpoints: Suscripci√≥n Gen√©rica (suscripcion.routes.js)
Esta secci√≥n define el √∫nico endpoint expuesto por este m√≥dulo, que es un verbo espec√≠fico (/cancelar) para evitar conflictos con las rutas CRUD gen√©ricas de otros controladores.

M√©todo HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Prop√≥sito y Requisitos de Seguridad
PUT	/api/suscripciones/:id/cancelar	authenticate	suscripcionController.cancel	Permite al usuario cancelar su suscripci√≥n espec√≠fica (:id). Requiere Autenticaci√≥n y la validaci√≥n de propiedad interna.


Mapeo de Controladores: Transacciones y Flujo de Pago (transaccion.controller.js)
Este controlador se centra en la gesti√≥n y consulta de los registros de transacciones. Su funci√≥n m√°s cr√≠tica es confirmarTransaccion, que asegura que el cambio de estado de una transacci√≥n y sus efectos asociados (como crear suscripciones o cerrar pujas) sean at√≥micos.

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
create	Crea una nueva transacci√≥n.	Llama a transaccionService.create(). Aunque existe, las transacciones se crean principalmente como parte de flujos mayores (suscripciones, pujas).	201 (Created). 400 (Datos inv√°lidos).
confirmarTransaccion	CR√çTICO: Procesa y confirma una transacci√≥n como pagada (usado por webhooks o Administrador).	Envuelve el proceso en una transacci√≥n de Sequelize (t) para garantizar que, si falla alguna actualizaci√≥n subsiguiente (ej. crear una suscripci√≥n), todo se revierta (t.rollback()). Llama a transaccionService.confirmarTransaccion().	200 (OK). 400 (Error de l√≥gica o servicio).
findMyTransactions	Obtiene todas las transacciones del usuario autenticado.	Llama a transaccionService.findByUserId(userId).	200 (OK).
findMyTransactionById	Obtiene una transacci√≥n espec√≠fica del usuario.	Llama a transaccionService.findByIdAndUserId(id, userId), validando la propiedad.	200 (OK). 404 (No encontrada o no pertenece).
findAll	Obtiene todas las transacciones del sistema.	Llama a transaccionService.findAll(). Solo para Administradores.	200 (OK).
CRUD Gen√©rico	Funciones CRUD para Administradores.	findById, update, softDelete. Permiten la gesti√≥n completa por parte de un usuario con rol Admin.	200 (OK) / 204 (No Content). 404 (Not Found).


7.33. Mapeo de Endpoints: Transacci√≥n (transaccion.routes.js)
Las rutas est√°n organizadas para priorizar las consultas del usuario final (/mis_transacciones) antes de exponer las rutas din√°micas para la administraci√≥n.

M√©todo HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Prop√≥sito y Requisitos de Seguridad
GET	/api/transacciones/	authenticate -> authorizeAdmin	transaccionController.findAll	Lista todas las transacciones del sistema. Requiere Admin.
PUT	/api/transacciones/:id/confirmar	authenticate -> authorizeAdmin	transaccionController.confirmarTransaccion	Ruta de administrador para forzar la confirmaci√≥n de una transacci√≥n.
GET	/api/transacciones/mis_transacciones	authenticate	transaccionController.findMyTransactions	Obtiene la lista de transacciones del usuario.
GET	/api/transacciones/mis_transacciones/:id	authenticate	transaccionController.findMyTransactionById	Obtiene una transacci√≥n espec√≠fica del usuario, validando la propiedad.
PUT	/api/transacciones/mis_transacciones/:id	authenticate	transaccionController.updateMyTransaction	Permite al usuario actualizar su propia transacci√≥n (si aplica).
GET	/api/transacciones/:id	authenticate -> authorizeAdmin	transaccionController.findById	Obtiene una transacci√≥n por ID (Admin).
PUT	/api/transacciones/:id	authenticate -> authorizeAdmin	transaccionController.update	Actualiza una transacci√≥n por ID (Admin).
DELETE	/api/transacciones/:id	authenticate -> authorizeAdmin	transaccionController.softDelete	Eliminaci√≥n l√≥gica de una transacci√≥n por ID (Admin).

Mapeo de Controladores: Usuarios y Autenticaci√≥n (usuario.controller.js)
Este controlador administra la funcionalidad central de la plataforma, incluyendo el registro, la gesti√≥n del perfil propio del usuario (/me) y la capacidad de los administradores para realizar el CRUD completo sobre todos los usuarios.

Funci√≥n del Controlador	Prop√≥sito Principal	L√≥gica Cr√≠tica y Servicios Utilizados	C√≥digos de Respuesta Clave para el Frontend
create	Registra un nuevo usuario.	Llama a usuarioService.create(). El servicio maneja el hashing de la contrase√±a y la generaci√≥n del token de confirmaci√≥n de email. Oculta datos sensibles en la respuesta.	201 (Created). 400 (Validaci√≥n fallida, ej: email duplicado).
confirmEmail	Activa la cuenta de un usuario mediante el token recibido por correo.	Llama a usuarioService.confirmEmail(token). Actualiza email_confirmado: true.	200 (√âxito). 400 (Token inv√°lido o expirado).
findMe	Obtiene la informaci√≥n del perfil del usuario autenticado.	Usa req.user.id para buscar el perfil.	200 (OK). 404 (Usuario no encontrado).
updateMe	Actualiza la informaci√≥n del perfil del usuario autenticado.	Usa req.user.id para actualizar.	200 (OK). 400 (Validaci√≥n fallida).
softDeleteMe	Inhabilita la cuenta del usuario autenticado (Soft Delete).	Llama a usuarioService.softDelete(req.user.id).	204 (No Content).
findAll	Obtiene la lista completa de todos los usuarios (activos e inactivos).	Llama a usuarioService.findAll(). Solo para Administradores.	200 (OK).
findAllActivo	Obtiene la lista de usuarios con cuenta activa (activo: true).	Llama a usuarioService.findAllActivo(). Solo para Administradores.	200 (OK).
CRUD Admin	findById, update, softDelete.	Permite la gesti√≥n completa de cualquier usuario por su ID. Requiere rol Admin.	200 (OK) / 204 (No Content). 404 (Not Found).


7.35. Mapeo de Endpoints: Usuarios y Seguridad (usuario.routes.js)
El orden de las rutas es cr√≠tico para evitar que las rutas est√°ticas (/confirmar, /me, /activos) sean interpretadas err√≥neamente como un ID (/:id).

M√©todo HTTP	Endpoint Completo	Middleware Flow	Controlador Mapeado	Prop√≥sito y Requisitos de Seguridad
POST	/api/usuarios/	N/A (P√∫blico)	usuarioController.create	Registro de nuevo usuario.
GET	/api/usuarios/confirmar/:token	N/A (P√∫blico)	usuarioController.confirmEmail	Enlace de activaci√≥n por correo electr√≥nico.
GET	/api/usuarios/me	authenticate	usuarioController.findMe	Obtener perfil del usuario autenticado.
PUT	/api/usuarios/me	authenticate	usuarioController.updateMe	Actualizar perfil del usuario autenticado.
DELETE	/api/usuarios/me	authenticate	usuarioController.softDeleteMe	Desactivar/Eliminar perfil propio.
GET	/api/usuarios/	authenticate -> authorizeAdmin	usuarioController.findAll	Lista todos los usuarios. Requiere Admin.
GET	/api/usuarios/activos	authenticate -> authorizeAdmin	usuarioController.findAllActivo	Lista solo usuarios activos. Requiere Admin.
GET	/api/usuarios/:id	authenticate -> authorizeAdmin	usuarioController.findById	Obtiene un usuario por ID. Requiere Admin.
PUT	/api/usuarios/:id	authenticate -> authorizeAdmin	usuarioController.update	Actualiza un usuario por ID. Requiere Admin.
DELETE	/api/usuarios/:id	authenticate -> authorizeAdmin	usuarioController.softDelete	Eliminaci√≥n l√≥gica de un usuario por ID. Requiere Admin.
















